[/
 / Copyright (c) 2003-2023 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[xinclude quickref.xml]

[include requirements/asynchronous_operations.qbk]
[include requirements/read_write_operations.qbk]
[include requirements/synchronous_socket_operations.qbk]
[include requirements/asynchronous_socket_operations.qbk]
[include requirements/AcceptableProtocol.qbk]
[include requirements/AcceptHandler.qbk]
[include requirements/AcceptToken.qbk]
[include requirements/AsyncRandomAccessReadDevice.qbk]
[include requirements/AsyncRandomAccessWriteDevice.qbk]
[include requirements/AsyncReadStream.qbk]
[include requirements/AsyncWriteStream.qbk]
[include requirements/BufferedHandshakeHandler.qbk]
[include requirements/BufferedHandshakeToken.qbk]
[include requirements/CancellationHandler.qbk]
[include requirements/CancellationSlot.qbk]
[include requirements/CompletionCondition.qbk]
[include requirements/ConnectCondition.qbk]
[include requirements/ConnectHandler.qbk]
[include requirements/ConnectToken.qbk]
[include requirements/ConstBufferSequence.qbk]
[include requirements/DynamicBuffer.qbk]
[include requirements/DynamicBuffer_v1.qbk]
[include requirements/DynamicBuffer_v2.qbk]
[include requirements/Endpoint.qbk]
[include requirements/EndpointSequence.qbk]
[include requirements/ExecutionContext.qbk]
[include requirements/Executor.qbk]
[include requirements/GettableSerialPortOption.qbk]
[include requirements/GettableSocketOption.qbk]
[include requirements/Handler.qbk]
[include requirements/HandshakeHandler.qbk]
[include requirements/HandshakeToken.qbk]
[include requirements/InternetProtocol.qbk]
[include requirements/IoControlCommand.qbk]
[include requirements/IoObjectService.qbk]
[include requirements/IteratorConnectHandler.qbk]
[include requirements/IteratorConnectToken.qbk]
[include requirements/LegacyCompletionHandler.qbk]
[include requirements/MoveAcceptHandler.qbk]
[include requirements/MoveAcceptToken.qbk]
[include requirements/MutableBufferSequence.qbk]
[include requirements/NullaryToken.qbk]
[include requirements/OperationState.qbk]
[include requirements/ProtoAllocator.qbk]
[include requirements/Protocol.qbk]
[include requirements/RangeConnectHandler.qbk]
[include requirements/RangeConnectToken.qbk]
[include requirements/ReadHandler.qbk]
[include requirements/ReadToken.qbk]
[include requirements/Receiver.qbk]
[include requirements/ResolveHandler.qbk]
[include requirements/ResolveToken.qbk]
[include requirements/Scheduler.qbk]
[include requirements/Sender.qbk]
[include requirements/Service.qbk]
[include requirements/SettableSerialPortOption.qbk]
[include requirements/SettableSocketOption.qbk]
[include requirements/ShutdownHandler.qbk]
[include requirements/ShutdownToken.qbk]
[include requirements/SignalHandler.qbk]
[include requirements/SignalToken.qbk]
[include requirements/SyncRandomAccessReadDevice.qbk]
[include requirements/SyncRandomAccessWriteDevice.qbk]
[include requirements/SyncReadStream.qbk]
[include requirements/SyncWriteStream.qbk]
[include requirements/TimeTraits.qbk]
[include requirements/WaitHandler.qbk]
[include requirements/WaitToken.qbk]
[include requirements/WaitTraits.qbk]
[include requirements/WriteHandler.qbk]
[include requirements/WriteToken.qbk]


[section:allocator_binder allocator_binder]

[indexterm1 boost_asio.indexterm.allocator_binder..allocator_binder]


A call wrapper type to bind an allocator of type `Allocator` to an object of type `T`. 


  template<
      typename T,
      typename Allocator>
  class allocator_binder


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.allocator_binder.allocator_type [*allocator_type]]]
    [The type of the associated allocator. ]
  
  ]

  [

    [[link boost_asio.reference.allocator_binder.argument_type [*argument_type]]]
    [The type of the function's argument. ]
  
  ]

  [

    [[link boost_asio.reference.allocator_binder.first_argument_type [*first_argument_type]]]
    [The type of the function's first argument. ]
  
  ]

  [

    [[link boost_asio.reference.allocator_binder.result_type [*result_type]]]
    [The return type if a function. ]
  
  ]

  [

    [[link boost_asio.reference.allocator_binder.second_argument_type [*second_argument_type]]]
    [The type of the function's second argument. ]
  
  ]

  [

    [[link boost_asio.reference.allocator_binder.target_type [*target_type]]]
    [The type of the target object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.allocator_binder.allocator_binder [*allocator_binder]] [constructor]]
    [Construct an allocator wrapper for the specified object. 
     [hr]
     Copy constructor. 
     [hr]
     Construct a copy, but specify a different allocator. 
     [hr]
     Construct a copy of a different allocator wrapper type. 
     [hr]
     Construct a copy of a different allocator wrapper type, but specify a different allocator. 
     [hr]
     Move constructor. 
     [hr]
     Move construct the target object, but specify a different allocator. 
     [hr]
     Move construct from a different allocator wrapper type. 
     [hr]
     Move construct from a different allocator wrapper type, but specify a different allocator. ]
  ]
  
  [
    [[link boost_asio.reference.allocator_binder.get [*get]]]
    [Obtain a reference to the target object. ]
  ]
  
  [
    [[link boost_asio.reference.allocator_binder.get_allocator [*get_allocator]]]
    [Obtain the associated allocator. ]
  ]
  
  [
    [[link boost_asio.reference.allocator_binder.operator_lp__rp_ [*operator()]]]
    []
  ]
  
  [
    [[link boost_asio.reference.allocator_binder._allocator_binder [*~allocator_binder]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:allocator_binder allocator_binder::allocator_binder]

[indexterm2 boost_asio.indexterm.allocator_binder.allocator_binder..allocator_binder..allocator_binder] 
Construct an allocator wrapper for the specified object. 


  template<
      typename U>
  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload1 allocator_binder]``(
      const allocator_type & s,
      U && u);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload2 allocator_binder]``(
      const allocator_binder & other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload2 more...]]``


Construct a copy, but specify a different allocator. 


  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload3 allocator_binder]``(
      const allocator_type & s,
      const allocator_binder & other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload3 more...]]``


Construct a copy of a different allocator wrapper type. 


  template<
      typename U,
      typename OtherAllocator>
  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload4 allocator_binder]``(
      const allocator_binder< U, OtherAllocator > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload4 more...]]``


Construct a copy of a different allocator wrapper type, but specify a different allocator. 


  template<
      typename U,
      typename OtherAllocator>
  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload5 allocator_binder]``(
      const allocator_type & s,
      const allocator_binder< U, OtherAllocator > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload5 more...]]``


Move constructor. 


  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload6 allocator_binder]``(
      allocator_binder && other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload6 more...]]``


Move construct the target object, but specify a different allocator. 


  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload7 allocator_binder]``(
      const allocator_type & s,
      allocator_binder && other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload7 more...]]``


Move construct from a different allocator wrapper type. 


  template<
      typename U,
      typename OtherAllocator>
  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload8 allocator_binder]``(
      allocator_binder< U, OtherAllocator > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload8 more...]]``


Move construct from a different allocator wrapper type, but specify a different allocator. 


  template<
      typename U,
      typename OtherAllocator>
  ``[link boost_asio.reference.allocator_binder.allocator_binder.overload9 allocator_binder]``(
      const allocator_type & s,
      allocator_binder< U, OtherAllocator > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.allocator_binder.overload9 more...]]``


[section:overload1 allocator_binder::allocator_binder (1 of 9 overloads)]


Construct an allocator wrapper for the specified object. 


  template<
      typename U>
  allocator_binder(
      const allocator_type & s,
      U && u);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload2 allocator_binder::allocator_binder (2 of 9 overloads)]


Copy constructor. 


  allocator_binder(
      const allocator_binder & other);



[endsect]



[section:overload3 allocator_binder::allocator_binder (3 of 9 overloads)]


Construct a copy, but specify a different allocator. 


  allocator_binder(
      const allocator_type & s,
      const allocator_binder & other);



[endsect]



[section:overload4 allocator_binder::allocator_binder (4 of 9 overloads)]


Construct a copy of a different allocator wrapper type. 


  template<
      typename U,
      typename OtherAllocator>
  allocator_binder(
      const allocator_binder< U, OtherAllocator > & other);


This constructor is only valid if the `Allocator` type is constructible from type `OtherAllocator`, and the type `T` is constructible from type `U`. 


[endsect]



[section:overload5 allocator_binder::allocator_binder (5 of 9 overloads)]


Construct a copy of a different allocator wrapper type, but specify a different allocator. 


  template<
      typename U,
      typename OtherAllocator>
  allocator_binder(
      const allocator_type & s,
      const allocator_binder< U, OtherAllocator > & other);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload6 allocator_binder::allocator_binder (6 of 9 overloads)]


Move constructor. 


  allocator_binder(
      allocator_binder && other);



[endsect]



[section:overload7 allocator_binder::allocator_binder (7 of 9 overloads)]


Move construct the target object, but specify a different allocator. 


  allocator_binder(
      const allocator_type & s,
      allocator_binder && other);



[endsect]



[section:overload8 allocator_binder::allocator_binder (8 of 9 overloads)]


Move construct from a different allocator wrapper type. 


  template<
      typename U,
      typename OtherAllocator>
  allocator_binder(
      allocator_binder< U, OtherAllocator > && other);



[endsect]



[section:overload9 allocator_binder::allocator_binder (9 of 9 overloads)]


Move construct from a different allocator wrapper type, but specify a different allocator. 


  template<
      typename U,
      typename OtherAllocator>
  allocator_binder(
      const allocator_type & s,
      allocator_binder< U, OtherAllocator > && other);



[endsect]


[endsect]


[section:allocator_type allocator_binder::allocator_type]

[indexterm2 boost_asio.indexterm.allocator_binder.allocator_type..allocator_type..allocator_binder] 
The type of the associated allocator. 


  typedef Allocator allocator_type;



[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:argument_type allocator_binder::argument_type]

[indexterm2 boost_asio.indexterm.allocator_binder.argument_type..argument_type..allocator_binder] 
The type of the function's argument. 


  typedef see_below argument_type;



The type of `argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting a single argument, `argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `argument_type`, then `argument_type` is a synonym for `T::argument_type`;


* otherwise `argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:first_argument_type allocator_binder::first_argument_type]

[indexterm2 boost_asio.indexterm.allocator_binder.first_argument_type..first_argument_type..allocator_binder] 
The type of the function's first argument. 


  typedef see_below first_argument_type;



The type of `first_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `first_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `first_argument_type` is a synonym for `T::first_argument_type`;


* otherwise `first_argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:get allocator_binder::get]

[indexterm2 boost_asio.indexterm.allocator_binder.get..get..allocator_binder] 
Obtain a reference to the target object. 


  target_type & ``[link boost_asio.reference.allocator_binder.get.overload1 get]``();
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.get.overload1 more...]]``

  const target_type & ``[link boost_asio.reference.allocator_binder.get.overload2 get]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.get.overload2 more...]]``


[section:overload1 allocator_binder::get (1 of 2 overloads)]


Obtain a reference to the target object. 


  target_type & get();



[endsect]



[section:overload2 allocator_binder::get (2 of 2 overloads)]


Obtain a reference to the target object. 


  const target_type & get() const;



[endsect]


[endsect]


[section:get_allocator allocator_binder::get_allocator]

[indexterm2 boost_asio.indexterm.allocator_binder.get_allocator..get_allocator..allocator_binder] 
Obtain the associated allocator. 


  allocator_type get_allocator() const;



[endsect]


[section:operator_lp__rp_ allocator_binder::operator()]

[indexterm2 boost_asio.indexterm.allocator_binder.operator_lp__rp_..operator()..allocator_binder] 

  template<
      typename... Args>
  auto ``[link boost_asio.reference.allocator_binder.operator_lp__rp_.overload1 operator()]``(
      Args && ...);
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.operator_lp__rp_.overload1 more...]]``

  template<
      typename... Args>
  auto ``[link boost_asio.reference.allocator_binder.operator_lp__rp_.overload2 operator()]``(
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.allocator_binder.operator_lp__rp_.overload2 more...]]``


[section:overload1 allocator_binder::operator() (1 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...);



[endsect]



[section:overload2 allocator_binder::operator() (2 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...) const;



[endsect]


[endsect]


[section:result_type allocator_binder::result_type]

[indexterm2 boost_asio.indexterm.allocator_binder.result_type..result_type..allocator_binder] 
The return type if a function. 


  typedef see_below result_type;



The type of `result_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to function type, `result_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `result_type`, then `result_type` is a synonym for `T::result_type`;


* otherwise `result_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:second_argument_type allocator_binder::second_argument_type]

[indexterm2 boost_asio.indexterm.allocator_binder.second_argument_type..second_argument_type..allocator_binder] 
The type of the function's second argument. 


  typedef see_below second_argument_type;



The type of `second_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `second_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `second_argument_type` is a synonym for `T::second_argument_type`;


* otherwise `second_argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:target_type allocator_binder::target_type]

[indexterm2 boost_asio.indexterm.allocator_binder.target_type..target_type..allocator_binder] 
The type of the target object. 


  typedef T target_type;



[heading Requirements]

['Header: ][^boost/asio/bind_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_allocator_binder allocator_binder::~allocator_binder]

[indexterm2 boost_asio.indexterm.allocator_binder._allocator_binder..~allocator_binder..allocator_binder] 
Destructor. 


  ~allocator_binder();



[endsect]



[endsect]

[section:any_completion_executor any_completion_executor]

[indexterm1 boost_asio.indexterm.any_completion_executor..any_completion_executor]


Polymorphic executor type for use with I/O objects. 


  class any_completion_executor :
    public execution::any_executor< SupportableProperties >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_executor.any_completion_executor [*any_completion_executor]] [constructor]]
    [Default constructor. 
     [hr]
     Construct in an empty state. Equivalent effects to default constructor. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. 
     [hr]
     Construct to point to the same target as another any_executor. 
     [hr]
     Construct a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.execute [*execute]]]
    [Execute the function on the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.operator_bool [*operator bool]]]
    [Determine whether the wrapper has a target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. 
     [hr]
     Assignment operator that sets the polymorphic wrapper to the empty state. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.prefer [*prefer]]]
    [Obtain a polymorphic wrapper with the specified property. 
     [hr]
     ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.query [*query]]]
    [Obtain the value associated with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.require [*require]]]
    [Obtain a polymorphic wrapper with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.swap [*swap]]]
    [Swap targets with another polymorphic wrapper. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.target [*target]]]
    [Get a pointer to the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.target_type [*target_type]]]
    [Get the type of the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor._any_completion_executor [*~any_completion_executor]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_executor.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_executor.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

The `any_completion_executor` type is a polymorphic executor that supports the set of properties required for the execution of completion handlers. It is defined as the [link boost_asio.reference.execution__any_executor `execution::any_executor`] class template parameterised as follows: 

   execution::any_executor<
     execution::prefer_only<execution::outstanding_work_t::tracked_t>,
     execution::prefer_only<execution::outstanding_work_t::untracked_t>
     execution::prefer_only<execution::relationship_t::fork_t>,
     execution::prefer_only<execution::relationship_t::continuation_t>
   > 




[heading Requirements]

['Header: ][^boost/asio/any_completion_executor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:any_completion_executor any_completion_executor::any_completion_executor]

[indexterm2 boost_asio.indexterm.any_completion_executor.any_completion_executor..any_completion_executor..any_completion_executor] 
Default constructor. 


  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload1 any_completion_executor]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload1 more...]]``


Construct in an empty state. Equivalent effects to default constructor. 


  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload2 any_completion_executor]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload3 any_completion_executor]``(
      const any_completion_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload3 more...]]``


Move constructor. 


  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload4 any_completion_executor]``(
      any_completion_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload4 more...]]``


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload5 any_completion_executor]``(
      execution::any_executor< OtherSupportableProperties...> e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload5 more...]]``

  template<
      class... OtherSupportableProperties>
  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload6 any_completion_executor]``(
      std::nothrow_t ,
      execution::any_executor< OtherSupportableProperties...> e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload6 more...]]``

  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload7 any_completion_executor]``(
      std::nothrow_t ,
      const any_completion_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload7 more...]]``

  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload8 any_completion_executor]``(
      std::nothrow_t ,
      any_completion_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload8 more...]]``


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload9 any_completion_executor]``(
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.any_completion_executor.any_completion_executor.overload10 any_completion_executor]``(
      std::nothrow_t ,
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.any_completion_executor.overload10 more...]]``


[section:overload1 any_completion_executor::any_completion_executor (1 of 10 overloads)]


Default constructor. 


  any_completion_executor();



[endsect]



[section:overload2 any_completion_executor::any_completion_executor (2 of 10 overloads)]


Construct in an empty state. Equivalent effects to default constructor. 


  any_completion_executor(
      nullptr_t );



[endsect]



[section:overload3 any_completion_executor::any_completion_executor (3 of 10 overloads)]


Copy constructor. 


  any_completion_executor(
      const any_completion_executor & e);



[endsect]



[section:overload4 any_completion_executor::any_completion_executor (4 of 10 overloads)]


Move constructor. 


  any_completion_executor(
      any_completion_executor && e);



[endsect]



[section:overload5 any_completion_executor::any_completion_executor (5 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  any_completion_executor(
      execution::any_executor< OtherSupportableProperties...> e);



[endsect]



[section:overload6 any_completion_executor::any_completion_executor (6 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  any_completion_executor(
      std::nothrow_t ,
      execution::any_executor< OtherSupportableProperties...> e);



[endsect]



[section:overload7 any_completion_executor::any_completion_executor (7 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  any_completion_executor(
      std::nothrow_t ,
      const any_completion_executor & e);



[endsect]



[section:overload8 any_completion_executor::any_completion_executor (8 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  any_completion_executor(
      std::nothrow_t ,
      any_completion_executor && e);



[endsect]



[section:overload9 any_completion_executor::any_completion_executor (9 of 10 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_completion_executor(
      Executor e);



[endsect]



[section:overload10 any_completion_executor::any_completion_executor (10 of 10 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_completion_executor(
      std::nothrow_t ,
      Executor e);



[endsect]


[endsect]


[section:context any_completion_executor::context]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_completion_executor.context..context..any_completion_executor] 
Obtain the underlying execution context. 


  automatically_determined context() const;


This function is provided for backward compatibility. It is automatically defined when the `SupportableProperties`... list includes a property of type `execution::context_as<U>`, for some type `U`. 


[endsect]



[section:execute any_completion_executor::execute]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_completion_executor.execute..execute..any_completion_executor] 
Execute the function on the target executor. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Throws [link boost_asio.reference.bad_executor `bad_executor`] if the polymorphic wrapper has no target. 


[endsect]



[section:operator_bool any_completion_executor::operator bool]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_completion_executor.operator_bool..operator bool..any_completion_executor] 
Determine whether the wrapper has a target executor. 


  operator bool() const;



[heading Return Value]
      
`true` if the polymorphic wrapper has a target executor, otherwise false. 




[endsect]


[section:operator_not__eq_ any_completion_executor::operator!=]

[indexterm2 boost_asio.indexterm.any_completion_executor.operator_not__eq_..operator!=..any_completion_executor] 
Inequality operator. 


  bool ``[link boost_asio.reference.any_completion_executor.operator_not__eq_.overload1 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_not__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.any_completion_executor.operator_not__eq_.overload2 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_not__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.any_completion_executor.operator_not__eq_.overload3 operator!=]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_not__eq_.overload3 more...]]``


[section:overload1 any_completion_executor::operator!= (1 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 any_completion_executor::operator!= (2 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 any_completion_executor::operator!= (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:operator_eq_ any_completion_executor::operator=]

[indexterm2 boost_asio.indexterm.any_completion_executor.operator_eq_..operator=..any_completion_executor] 
Assignment operator. 


  any_completion_executor & ``[link boost_asio.reference.any_completion_executor.operator_eq_.overload1 operator=]``(
      const any_completion_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_eq_.overload1 more...]]``


Move assignment operator. 


  any_completion_executor & ``[link boost_asio.reference.any_completion_executor.operator_eq_.overload2 operator=]``(
      any_completion_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_eq_.overload2 more...]]``


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_completion_executor & ``[link boost_asio.reference.any_completion_executor.operator_eq_.overload3 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_eq_.overload3 more...]]``


[section:overload1 any_completion_executor::operator= (1 of 3 overloads)]


Assignment operator. 


  any_completion_executor & operator=(
      const any_completion_executor & e);



[endsect]



[section:overload2 any_completion_executor::operator= (2 of 3 overloads)]


Move assignment operator. 


  any_completion_executor & operator=(
      any_completion_executor && e);



[endsect]



[section:overload3 any_completion_executor::operator= (3 of 3 overloads)]


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_completion_executor & operator=(
      nullptr_t );



[endsect]


[endsect]

[section:operator_eq__eq_ any_completion_executor::operator==]

[indexterm2 boost_asio.indexterm.any_completion_executor.operator_eq__eq_..operator==..any_completion_executor] 
Equality operator. 


  bool ``[link boost_asio.reference.any_completion_executor.operator_eq__eq_.overload1 operator==]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_eq__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.any_completion_executor.operator_eq__eq_.overload2 operator==]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_eq__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.any_completion_executor.operator_eq__eq_.overload3 operator==]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.operator_eq__eq_.overload3 more...]]``


[section:overload1 any_completion_executor::operator== (1 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 any_completion_executor::operator== (2 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 any_completion_executor::operator== (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:prefer any_completion_executor::prefer]

[indexterm2 boost_asio.indexterm.any_completion_executor.prefer..prefer..any_completion_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_completion_executor ``[link boost_asio.reference.any_completion_executor.prefer.overload1 prefer]``(
      const Property & p,
      typename constraint< traits::prefer_member< const base_type &, const Property & >::is_valid >::type  = 0) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.prefer.overload1 more...]]``



  template<>
  any_completion_executor ``[link boost_asio.reference.any_completion_executor.prefer.overload2 prefer]``(
      const execution::outstanding_work_t::tracked_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.prefer.overload2 more...]]``

  template<>
  any_completion_executor ``[link boost_asio.reference.any_completion_executor.prefer.overload3 prefer]``(
      const execution::outstanding_work_t::untracked_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.prefer.overload3 more...]]``

  template<>
  any_completion_executor ``[link boost_asio.reference.any_completion_executor.prefer.overload4 prefer]``(
      const execution::relationship_t::fork_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.prefer.overload4 more...]]``

  template<>
  any_completion_executor ``[link boost_asio.reference.any_completion_executor.prefer.overload5 prefer]``(
      const execution::relationship_t::continuation_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.prefer.overload5 more...]]``

  template<
      typename Property>
  any_executor ``[link boost_asio.reference.any_completion_executor.prefer.overload6 prefer]``(
      Property ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.prefer.overload6 more...]]``


[section:overload1 any_completion_executor::prefer (1 of 6 overloads)]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_completion_executor prefer(
      const Property & p,
      typename constraint< traits::prefer_member< const base_type &, const Property & >::is_valid >::type  = 0) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   any_completion_executor ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::relationship.fork); 





[endsect]



[section:overload2 any_completion_executor::prefer (2 of 6 overloads)]



  template<>
  any_completion_executor prefer(
      const execution::outstanding_work_t::tracked_t & p,
      int ) const;



[endsect]



[section:overload3 any_completion_executor::prefer (3 of 6 overloads)]



  template<>
  any_completion_executor prefer(
      const execution::outstanding_work_t::untracked_t & p,
      int ) const;



[endsect]



[section:overload4 any_completion_executor::prefer (4 of 6 overloads)]



  template<>
  any_completion_executor prefer(
      const execution::relationship_t::fork_t & p,
      int ) const;



[endsect]



[section:overload5 any_completion_executor::prefer (5 of 6 overloads)]



  template<>
  any_completion_executor prefer(
      const execution::relationship_t::continuation_t & p,
      int ) const;



[endsect]



[section:overload6 any_completion_executor::prefer (6 of 6 overloads)]


['Inherited from execution::any_executor.]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor prefer(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::blocking.possibly); 





[endsect]


[endsect]


[section:query any_completion_executor::query]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_completion_executor.query..query..any_completion_executor] 
Obtain the value associated with the specified property. 


  template<
      typename Property>
  Property::polymorphic_query_result_type query(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   execution::any_executor<execution::occupancy_t> ex = ...;
   size_t n = boost::asio::query(ex, execution::occupancy); 





[endsect]


[section:require any_completion_executor::require]

[indexterm2 boost_asio.indexterm.any_completion_executor.require..require..any_completion_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_completion_executor ``[link boost_asio.reference.any_completion_executor.require.overload1 require]``(
      const Property & p,
      typename constraint< traits::require_member< const base_type &, const Property & >::is_valid >::type  = 0) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.require.overload1 more...]]``

  template<
      typename Property>
  any_executor ``[link boost_asio.reference.any_completion_executor.require.overload2 require]``(
      Property ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.require.overload2 more...]]``


[section:overload1 any_completion_executor::require (1 of 2 overloads)]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_completion_executor require(
      const Property & p,
      typename constraint< traits::require_member< const base_type &, const Property & >::is_valid >::type  = 0) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   any_completion_executor ex = ...;
   auto ex2 = boost::asio::require(ex, execution::relationship.fork); 





[endsect]



[section:overload2 any_completion_executor::require (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor require(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::requre(ex, execution::blocking.possibly); 





[endsect]


[endsect]

[section:swap any_completion_executor::swap]

[indexterm2 boost_asio.indexterm.any_completion_executor.swap..swap..any_completion_executor] 
Swap targets with another polymorphic wrapper. 


  void ``[link boost_asio.reference.any_completion_executor.swap.overload1 swap]``(
      any_completion_executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.swap.overload1 more...]]``

  void ``[link boost_asio.reference.any_completion_executor.swap.overload2 swap]``(
      any_executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.swap.overload2 more...]]``


[section:overload1 any_completion_executor::swap (1 of 2 overloads)]


Swap targets with another polymorphic wrapper. 


  void swap(
      any_completion_executor & other);



[endsect]



[section:overload2 any_completion_executor::swap (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Swap targets with another polymorphic wrapper. 


  void swap(
      any_executor & other);



[endsect]


[endsect]

[section:target any_completion_executor::target]

[indexterm2 boost_asio.indexterm.any_completion_executor.target..target..any_completion_executor] 
Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * ``[link boost_asio.reference.any_completion_executor.target.overload1 target]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.target.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * ``[link boost_asio.reference.any_completion_executor.target.overload2 target]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_executor.target.overload2 more...]]``


[section:overload1 any_completion_executor::target (1 of 2 overloads)]


['Inherited from execution::any_executor.]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * target();



[endsect]



[section:overload2 any_completion_executor::target (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * target() const;



[endsect]


[endsect]


[section:target_type any_completion_executor::target_type]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_completion_executor.target_type..target_type..any_completion_executor] 
Get the type of the target executor. 


  const type_info & target_type() const;



[endsect]



[section:_any_completion_executor any_completion_executor::~any_completion_executor]

[indexterm2 boost_asio.indexterm.any_completion_executor._any_completion_executor..~any_completion_executor..any_completion_executor] 
Destructor. 


  ~any_completion_executor();



[endsect]



[endsect]

[section:any_completion_handler any_completion_handler]

[indexterm1 boost_asio.indexterm.any_completion_handler..any_completion_handler]


Polymorphic wrapper for completion handlers. 


  template<
      typename... Signatures>
  class any_completion_handler


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_handler.any_completion_handler [*any_completion_handler]] [constructor]]
    [Construct an any_completion_handler in an empty state, without a target object. 
     [hr]
     Construct an any_completion_handler to contain the specified target. 
     [hr]
     Move-construct an any_completion_handler from another. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.get_allocator [*get_allocator]]]
    [Get the associated allocator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.get_cancellation_slot [*get_cancellation_slot]]]
    [Get the associated cancellation slot. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.operator_bool [*operator bool]]]
    [Test if the polymorphic wrapper is empty. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.operator_not_ [*operator!]]]
    [Test if the polymorphic wrapper is non-empty. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.operator_lp__rp_ [*operator()]]]
    [Function call operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.operator_eq_ [*operator=]]]
    [Move-assign an any_completion_handler from another. 
     [hr]
     Assignment operator that sets the polymorphic wrapper to the empty state. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.swap [*swap]]]
    [Swap the content of an any_completion_handler with another. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler._any_completion_handler [*~any_completion_handler]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_handler.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

The `any_completion_handler` class template is a polymorphic wrapper for completion handlers that propagates the associated executor, associated allocator, and associated cancellation slot through a type-erasing interface.

When using `any_completion_handler`, specify one or more completion signatures as template parameters. These will dictate the arguments that may be passed to the handler through the polymorphic interface.

Typical uses for `any_completion_handler` include:


* Separate compilation of asynchronous operation implementations.


* Enabling interoperability between asynchronous operations and virtual functions. 



[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:any_completion_handler any_completion_handler::any_completion_handler]

[indexterm2 boost_asio.indexterm.any_completion_handler.any_completion_handler..any_completion_handler..any_completion_handler] 
Construct an `any_completion_handler` in an empty state, without a target object. 


  constexpr ``[link boost_asio.reference.any_completion_handler.any_completion_handler.overload1 any_completion_handler]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.any_completion_handler.overload1 more...]]``

  constexpr ``[link boost_asio.reference.any_completion_handler.any_completion_handler.overload2 any_completion_handler]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.any_completion_handler.overload2 more...]]``


Construct an `any_completion_handler` to contain the specified target. 


  template<
      typename H,
      typename ``[link boost_asio.reference.Handler Handler]`` = typename decay<H>::type>
  ``[link boost_asio.reference.any_completion_handler.any_completion_handler.overload3 any_completion_handler]``(
      H && h,
      typename constraint< !is_same< typename decay< H >::type, any_completion_handler >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.any_completion_handler.overload3 more...]]``


Move-construct an `any_completion_handler` from another. 


  ``[link boost_asio.reference.any_completion_handler.any_completion_handler.overload4 any_completion_handler]``(
      any_completion_handler && other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.any_completion_handler.overload4 more...]]``


[section:overload1 any_completion_handler::any_completion_handler (1 of 4 overloads)]


Construct an `any_completion_handler` in an empty state, without a target object. 


  constexpr any_completion_handler();



[endsect]



[section:overload2 any_completion_handler::any_completion_handler (2 of 4 overloads)]


Construct an `any_completion_handler` in an empty state, without a target object. 


  constexpr any_completion_handler(
      nullptr_t );



[endsect]



[section:overload3 any_completion_handler::any_completion_handler (3 of 4 overloads)]


Construct an `any_completion_handler` to contain the specified target. 


  template<
      typename H,
      typename ``[link boost_asio.reference.Handler Handler]`` = typename decay<H>::type>
  any_completion_handler(
      H && h,
      typename constraint< !is_same< typename decay< H >::type, any_completion_handler >::value >::type  = 0);



[endsect]



[section:overload4 any_completion_handler::any_completion_handler (4 of 4 overloads)]


Move-construct an `any_completion_handler` from another. 


  any_completion_handler(
      any_completion_handler && other);


After the operation, the moved-from object `other` has no target. 


[endsect]


[endsect]


[section:get_allocator any_completion_handler::get_allocator]

[indexterm2 boost_asio.indexterm.any_completion_handler.get_allocator..get_allocator..any_completion_handler] 
Get the associated allocator. 


  allocator_type get_allocator() const;



[endsect]



[section:get_cancellation_slot any_completion_handler::get_cancellation_slot]

[indexterm2 boost_asio.indexterm.any_completion_handler.get_cancellation_slot..get_cancellation_slot..any_completion_handler] 
Get the associated cancellation slot. 


  cancellation_slot_type get_cancellation_slot() const;



[endsect]



[section:operator_bool any_completion_handler::operator bool]

[indexterm2 boost_asio.indexterm.any_completion_handler.operator_bool..operator bool..any_completion_handler] 
Test if the polymorphic wrapper is empty. 


  constexpr operator bool() const;



[endsect]



[section:operator_not_ any_completion_handler::operator!]

[indexterm2 boost_asio.indexterm.any_completion_handler.operator_not_..operator!..any_completion_handler] 
Test if the polymorphic wrapper is non-empty. 


  constexpr bool operator!() const;



[endsect]


[section:operator_not__eq_ any_completion_handler::operator!=]

[indexterm2 boost_asio.indexterm.any_completion_handler.operator_not__eq_..operator!=..any_completion_handler] 
Inequality operator. 


  friend constexpr bool ``[link boost_asio.reference.any_completion_handler.operator_not__eq_.overload1 operator!=]``(
      const any_completion_handler & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.operator_not__eq_.overload1 more...]]``

  friend constexpr bool ``[link boost_asio.reference.any_completion_handler.operator_not__eq_.overload2 operator!=]``(
      nullptr_t ,
      const any_completion_handler & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.operator_not__eq_.overload2 more...]]``


[section:overload1 any_completion_handler::operator!= (1 of 2 overloads)]


Inequality operator. 


  friend constexpr bool operator!=(
      const any_completion_handler & a,
      nullptr_t );


[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 any_completion_handler::operator!= (2 of 2 overloads)]


Inequality operator. 


  friend constexpr bool operator!=(
      nullptr_t ,
      const any_completion_handler & b);


[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]


[section:operator_lp__rp_ any_completion_handler::operator()]

[indexterm2 boost_asio.indexterm.any_completion_handler.operator_lp__rp_..operator()..any_completion_handler] 
Function call operator. 


  template<
      typename... Args>
  auto operator()(
      Args &&... args);


Invokes target completion handler with the supplied arguments.

This function may only be called once, as the target handler is moved from. The polymorphic wrapper is left in an empty state.

Throws `std::bad_function_call` if the polymorphic wrapper is empty. 


[endsect]


[section:operator_eq_ any_completion_handler::operator=]

[indexterm2 boost_asio.indexterm.any_completion_handler.operator_eq_..operator=..any_completion_handler] 
Move-assign an `any_completion_handler` from another. 


  any_completion_handler & ``[link boost_asio.reference.any_completion_handler.operator_eq_.overload1 operator=]``(
      any_completion_handler && other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.operator_eq_.overload1 more...]]``


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_completion_handler & ``[link boost_asio.reference.any_completion_handler.operator_eq_.overload2 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.operator_eq_.overload2 more...]]``


[section:overload1 any_completion_handler::operator= (1 of 2 overloads)]


Move-assign an `any_completion_handler` from another. 


  any_completion_handler & operator=(
      any_completion_handler && other);


After the operation, the moved-from object `other` has no target. 


[endsect]



[section:overload2 any_completion_handler::operator= (2 of 2 overloads)]


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_completion_handler & operator=(
      nullptr_t );



[endsect]


[endsect]

[section:operator_eq__eq_ any_completion_handler::operator==]

[indexterm2 boost_asio.indexterm.any_completion_handler.operator_eq__eq_..operator==..any_completion_handler] 
Equality operator. 


  friend constexpr bool ``[link boost_asio.reference.any_completion_handler.operator_eq__eq_.overload1 operator==]``(
      const any_completion_handler & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.operator_eq__eq_.overload1 more...]]``

  friend constexpr bool ``[link boost_asio.reference.any_completion_handler.operator_eq__eq_.overload2 operator==]``(
      nullptr_t ,
      const any_completion_handler & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_completion_handler.operator_eq__eq_.overload2 more...]]``


[section:overload1 any_completion_handler::operator== (1 of 2 overloads)]


Equality operator. 


  friend constexpr bool operator==(
      const any_completion_handler & a,
      nullptr_t );


[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 any_completion_handler::operator== (2 of 2 overloads)]


Equality operator. 


  friend constexpr bool operator==(
      nullptr_t ,
      const any_completion_handler & b);


[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]


[section:swap any_completion_handler::swap]

[indexterm2 boost_asio.indexterm.any_completion_handler.swap..swap..any_completion_handler] 
Swap the content of an `any_completion_handler` with another. 


  void swap(
      any_completion_handler & other);



[endsect]



[section:_any_completion_handler any_completion_handler::~any_completion_handler]

[indexterm2 boost_asio.indexterm.any_completion_handler._any_completion_handler..~any_completion_handler..any_completion_handler] 
Destructor. 


  ~any_completion_handler();



[endsect]



[endsect]

[section:any_completion_handler_allocator any_completion_handler_allocator]

[indexterm1 boost_asio.indexterm.any_completion_handler_allocator..any_completion_handler_allocator]


An allocator type that forwards memory allocation operations through an instance of `any_completion_handler`. 


  template<
      typename T,
      typename... Signatures>
  class any_completion_handler_allocator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.any_completion_handler_allocator.value_type [*value_type]]]
    [The type of objects that may be allocated by the allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_handler_allocator.allocate [*allocate]]]
    [Allocate space for n objects of the allocator's value type. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.any_completion_handler_allocator [*any_completion_handler_allocator]] [constructor]]
    [Construct from another any_completion_handler_allocator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.deallocate [*deallocate]]]
    [Deallocate space for n objects of the allocator's value type. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:allocate any_completion_handler_allocator::allocate]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator.allocate..allocate..any_completion_handler_allocator] 
Allocate space for `n` objects of the allocator's value type. 


  T * allocate(
      std::size_t n) const;



[endsect]



[section:any_completion_handler_allocator any_completion_handler_allocator::any_completion_handler_allocator]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator.any_completion_handler_allocator..any_completion_handler_allocator..any_completion_handler_allocator] 
Construct from another `any_completion_handler_allocator`. 


  template<
      typename U>
  constexpr any_completion_handler_allocator(
      const any_completion_handler_allocator< U, Signatures...> & a);



[endsect]



[section:deallocate any_completion_handler_allocator::deallocate]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator.deallocate..deallocate..any_completion_handler_allocator] 
Deallocate space for `n` objects of the allocator's value type. 


  void deallocate(
      T * p,
      std::size_t n) const;



[endsect]



[section:operator_not__eq_ any_completion_handler_allocator::operator!=]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator.operator_not__eq_..operator!=..any_completion_handler_allocator] 
Inequality operator. 


  constexpr bool operator!=(
      const any_completion_handler_allocator & other) const;



[endsect]



[section:operator_eq__eq_ any_completion_handler_allocator::operator==]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator.operator_eq__eq_..operator==..any_completion_handler_allocator] 
Equality operator. 


  constexpr bool operator==(
      const any_completion_handler_allocator & other) const;



[endsect]



[section:value_type any_completion_handler_allocator::value_type]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator.value_type..value_type..any_completion_handler_allocator] 
The type of objects that may be allocated by the allocator. 


  typedef T value_type;



[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:any_completion_handler_allocator__rebind any_completion_handler_allocator::rebind]

[indexterm1 boost_asio.indexterm.any_completion_handler_allocator__rebind..any_completion_handler_allocator::rebind]


Rebinds an allocator to another value type. 


  template<
      typename U>
  struct rebind


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.any_completion_handler_allocator__rebind.other [*other]]]
    [Specifies the type of the rebound allocator. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other any_completion_handler_allocator::rebind::other]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator__rebind.other..other..any_completion_handler_allocator::rebind] 
Specifies the type of the rebound allocator. 


  typedef any_completion_handler_allocator< U, Signatures...> other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.any_completion_handler_allocator.value_type [*value_type]]]
    [The type of objects that may be allocated by the allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_handler_allocator.allocate [*allocate]]]
    [Allocate space for n objects of the allocator's value type. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.any_completion_handler_allocator [*any_completion_handler_allocator]] [constructor]]
    [Construct from another any_completion_handler_allocator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.deallocate [*deallocate]]]
    [Deallocate space for n objects of the allocator's value type. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_ any_completion_handler_allocator< void, Signatures...>]

[indexterm1 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_..any_completion_handler_allocator< void, Signatures\.\.\.>]


A protoco-allocator type that may be rebound to obtain an allocator that forwards memory allocation operations through an instance of `any_completion_handler`. 


  template<
      typename... Signatures>
  class any_completion_handler_allocator< void, Signatures...>


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.value_type [*value_type]]]
    [void as no objects can be allocated through a proto-allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.any_completion_handler_allocator [*any_completion_handler_allocator]]]
    [Construct from another any_completion_handler_allocator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:any_completion_handler_allocator any_completion_handler_allocator< void, Signatures...>::any_completion_handler_allocator]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.any_completion_handler_allocator..any_completion_handler_allocator..any_completion_handler_allocator< void, Signatures\.\.\.>] 
Construct from another `any_completion_handler_allocator`. 


  template<
      typename U>
  constexpr any_completion_handler_allocator(
      const any_completion_handler_allocator< U, Signatures...> & a);



[endsect]



[section:operator_not__eq_ any_completion_handler_allocator< void, Signatures...>::operator!=]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.operator_not__eq_..operator!=..any_completion_handler_allocator< void, Signatures\.\.\.>] 
Inequality operator. 


  constexpr bool operator!=(
      const any_completion_handler_allocator & other) const;



[endsect]



[section:operator_eq__eq_ any_completion_handler_allocator< void, Signatures...>::operator==]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.operator_eq__eq_..operator==..any_completion_handler_allocator< void, Signatures\.\.\.>] 
Equality operator. 


  constexpr bool operator==(
      const any_completion_handler_allocator & other) const;



[endsect]



[section:value_type any_completion_handler_allocator< void, Signatures...>::value_type]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt_.value_type..value_type..any_completion_handler_allocator< void, Signatures\.\.\.>] 
`void` as no objects can be allocated through a proto-allocator. 


  typedef void value_type;



[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt___rebind any_completion_handler_allocator< void, Signatures...>::rebind]

[indexterm1 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt___rebind..any_completion_handler_allocator< void, Signatures\.\.\.>::rebind]


Rebinds an allocator to another value type. 


  template<
      typename U>
  struct any_completion_handler_allocator< void, Signatures...>::rebind


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt___rebind.other [*other]]]
    [Specifies the type of the rebound allocator. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other any_completion_handler_allocator< void, Signatures...>::rebind::other]

[indexterm2 boost_asio.indexterm.any_completion_handler_allocator_lt__void_comma__Signatures_ellipsis__gt___rebind.other..other..any_completion_handler_allocator< void, Signatures\.\.\.>::rebind] 
Specifies the type of the rebound allocator. 


  typedef any_completion_handler_allocator< U, Signatures...> other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.any_completion_handler_allocator.value_type [*value_type]]]
    [The type of objects that may be allocated by the allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_completion_handler_allocator.allocate [*allocate]]]
    [Allocate space for n objects of the allocator's value type. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.any_completion_handler_allocator [*any_completion_handler_allocator]] [constructor]]
    [Construct from another any_completion_handler_allocator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.deallocate [*deallocate]]]
    [Deallocate space for n objects of the allocator's value type. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_completion_handler_allocator.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/any_completion_handler.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:any_io_executor any_io_executor]

[indexterm1 boost_asio.indexterm.any_io_executor..any_io_executor]


Polymorphic executor type for use with I/O objects. 


  class any_io_executor :
    public execution::any_executor< SupportableProperties >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_io_executor.any_io_executor [*any_io_executor]] [constructor]]
    [Default constructor. 
     [hr]
     Construct in an empty state. Equivalent effects to default constructor. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. 
     [hr]
     Construct to point to the same target as another any_executor. 
     [hr]
     Construct a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.execute [*execute]]]
    [Execute the function on the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.operator_bool [*operator bool]]]
    [Determine whether the wrapper has a target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. 
     [hr]
     Assignment operator that sets the polymorphic wrapper to the empty state. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.prefer [*prefer]]]
    [Obtain a polymorphic wrapper with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.query [*query]]]
    [Obtain the value associated with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.require [*require]]]
    [Obtain a polymorphic wrapper with the specified property. 
     [hr]
     ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.swap [*swap]]]
    [Swap targets with another polymorphic wrapper. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.target [*target]]]
    [Get a pointer to the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.target_type [*target_type]]]
    [Get the type of the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor._any_io_executor [*~any_io_executor]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_io_executor.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

The `any_io_executor` type is a polymorphic executor that supports the set of properties required by I/O objects. It is defined as the [link boost_asio.reference.execution__any_executor `execution::any_executor`] class template parameterised as follows: 

   execution::any_executor<
     execution::context_as_t<execution_context&>,
     execution::blocking_t::never_t,
     execution::prefer_only<execution::blocking_t::possibly_t>,
     execution::prefer_only<execution::outstanding_work_t::tracked_t>,
     execution::prefer_only<execution::outstanding_work_t::untracked_t>,
     execution::prefer_only<execution::relationship_t::fork_t>,
     execution::prefer_only<execution::relationship_t::continuation_t>
   > 




[heading Requirements]

['Header: ][^boost/asio/any_io_executor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:any_io_executor any_io_executor::any_io_executor]

[indexterm2 boost_asio.indexterm.any_io_executor.any_io_executor..any_io_executor..any_io_executor] 
Default constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload1 any_io_executor]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload1 more...]]``


Construct in an empty state. Equivalent effects to default constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload2 any_io_executor]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload3 any_io_executor]``(
      const any_io_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload3 more...]]``


Move constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload4 any_io_executor]``(
      any_io_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload4 more...]]``


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload5 any_io_executor]``(
      execution::any_executor< OtherSupportableProperties...> e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload5 more...]]``

  template<
      class... OtherSupportableProperties>
  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload6 any_io_executor]``(
      std::nothrow_t ,
      execution::any_executor< OtherSupportableProperties...> e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload6 more...]]``

  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload7 any_io_executor]``(
      std::nothrow_t ,
      const any_io_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload7 more...]]``

  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload8 any_io_executor]``(
      std::nothrow_t ,
      any_io_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload8 more...]]``


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload9 any_io_executor]``(
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload10 any_io_executor]``(
      std::nothrow_t ,
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload10 more...]]``


[section:overload1 any_io_executor::any_io_executor (1 of 10 overloads)]


Default constructor. 


  any_io_executor();



[endsect]



[section:overload2 any_io_executor::any_io_executor (2 of 10 overloads)]


Construct in an empty state. Equivalent effects to default constructor. 


  any_io_executor(
      nullptr_t );



[endsect]



[section:overload3 any_io_executor::any_io_executor (3 of 10 overloads)]


Copy constructor. 


  any_io_executor(
      const any_io_executor & e);



[endsect]



[section:overload4 any_io_executor::any_io_executor (4 of 10 overloads)]


Move constructor. 


  any_io_executor(
      any_io_executor && e);



[endsect]



[section:overload5 any_io_executor::any_io_executor (5 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  any_io_executor(
      execution::any_executor< OtherSupportableProperties...> e);



[endsect]



[section:overload6 any_io_executor::any_io_executor (6 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  any_io_executor(
      std::nothrow_t ,
      execution::any_executor< OtherSupportableProperties...> e);



[endsect]



[section:overload7 any_io_executor::any_io_executor (7 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  any_io_executor(
      std::nothrow_t ,
      const any_io_executor & e);



[endsect]



[section:overload8 any_io_executor::any_io_executor (8 of 10 overloads)]


Construct to point to the same target as another any\_executor. 


  any_io_executor(
      std::nothrow_t ,
      any_io_executor && e);



[endsect]



[section:overload9 any_io_executor::any_io_executor (9 of 10 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_io_executor(
      Executor e);



[endsect]



[section:overload10 any_io_executor::any_io_executor (10 of 10 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_io_executor(
      std::nothrow_t ,
      Executor e);



[endsect]


[endsect]


[section:context any_io_executor::context]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.context..context..any_io_executor] 
Obtain the underlying execution context. 


  automatically_determined context() const;


This function is provided for backward compatibility. It is automatically defined when the `SupportableProperties`... list includes a property of type `execution::context_as<U>`, for some type `U`. 


[endsect]



[section:execute any_io_executor::execute]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.execute..execute..any_io_executor] 
Execute the function on the target executor. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Throws [link boost_asio.reference.bad_executor `bad_executor`] if the polymorphic wrapper has no target. 


[endsect]



[section:operator_bool any_io_executor::operator bool]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_bool..operator bool..any_io_executor] 
Determine whether the wrapper has a target executor. 


  operator bool() const;



[heading Return Value]
      
`true` if the polymorphic wrapper has a target executor, otherwise false. 




[endsect]


[section:operator_not__eq_ any_io_executor::operator!=]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_not__eq_..operator!=..any_io_executor] 
Inequality operator. 


  bool ``[link boost_asio.reference.any_io_executor.operator_not__eq_.overload1 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_not__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_not__eq_.overload2 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_not__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_not__eq_.overload3 operator!=]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_not__eq_.overload3 more...]]``


[section:overload1 any_io_executor::operator!= (1 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 any_io_executor::operator!= (2 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 any_io_executor::operator!= (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:operator_eq_ any_io_executor::operator=]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_eq_..operator=..any_io_executor] 
Assignment operator. 


  any_io_executor & ``[link boost_asio.reference.any_io_executor.operator_eq_.overload1 operator=]``(
      const any_io_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq_.overload1 more...]]``


Move assignment operator. 


  any_io_executor & ``[link boost_asio.reference.any_io_executor.operator_eq_.overload2 operator=]``(
      any_io_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq_.overload2 more...]]``


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_io_executor & ``[link boost_asio.reference.any_io_executor.operator_eq_.overload3 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq_.overload3 more...]]``


[section:overload1 any_io_executor::operator= (1 of 3 overloads)]


Assignment operator. 


  any_io_executor & operator=(
      const any_io_executor & e);



[endsect]



[section:overload2 any_io_executor::operator= (2 of 3 overloads)]


Move assignment operator. 


  any_io_executor & operator=(
      any_io_executor && e);



[endsect]



[section:overload3 any_io_executor::operator= (3 of 3 overloads)]


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_io_executor & operator=(
      nullptr_t );



[endsect]


[endsect]

[section:operator_eq__eq_ any_io_executor::operator==]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_eq__eq_..operator==..any_io_executor] 
Equality operator. 


  bool ``[link boost_asio.reference.any_io_executor.operator_eq__eq_.overload1 operator==]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_eq__eq_.overload2 operator==]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_eq__eq_.overload3 operator==]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq__eq_.overload3 more...]]``


[section:overload1 any_io_executor::operator== (1 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 any_io_executor::operator== (2 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 any_io_executor::operator== (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:prefer any_io_executor::prefer]

[indexterm2 boost_asio.indexterm.any_io_executor.prefer..prefer..any_io_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload1 prefer]``(
      const Property & p,
      typename constraint< traits::prefer_member< const base_type &, const Property & >::is_valid >::type  = 0) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload1 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload2 prefer]``(
      const execution::blocking_t::possibly_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload2 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload3 prefer]``(
      const execution::outstanding_work_t::tracked_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload3 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload4 prefer]``(
      const execution::outstanding_work_t::untracked_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload4 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload5 prefer]``(
      const execution::relationship_t::fork_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload5 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload6 prefer]``(
      const execution::relationship_t::continuation_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload6 more...]]``

  template<
      typename Property>
  any_executor ``[link boost_asio.reference.any_io_executor.prefer.overload7 prefer]``(
      Property ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload7 more...]]``


[section:overload1 any_io_executor::prefer (1 of 7 overloads)]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor prefer(
      const Property & p,
      typename constraint< traits::prefer_member< const base_type &, const Property & >::is_valid >::type  = 0) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   any_io_executor ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::blocking.possibly); 





[endsect]



[section:overload2 any_io_executor::prefer (2 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::blocking_t::possibly_t & p,
      int ) const;



[endsect]



[section:overload3 any_io_executor::prefer (3 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::outstanding_work_t::tracked_t & p,
      int ) const;



[endsect]



[section:overload4 any_io_executor::prefer (4 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::outstanding_work_t::untracked_t & p,
      int ) const;



[endsect]



[section:overload5 any_io_executor::prefer (5 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::relationship_t::fork_t & p,
      int ) const;



[endsect]



[section:overload6 any_io_executor::prefer (6 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::relationship_t::continuation_t & p,
      int ) const;



[endsect]



[section:overload7 any_io_executor::prefer (7 of 7 overloads)]


['Inherited from execution::any_executor.]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor prefer(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::blocking.possibly); 





[endsect]


[endsect]


[section:query any_io_executor::query]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.query..query..any_io_executor] 
Obtain the value associated with the specified property. 


  template<
      typename Property>
  Property::polymorphic_query_result_type query(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   execution::any_executor<execution::occupancy_t> ex = ...;
   size_t n = boost::asio::query(ex, execution::occupancy); 





[endsect]


[section:require any_io_executor::require]

[indexterm2 boost_asio.indexterm.any_io_executor.require..require..any_io_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor ``[link boost_asio.reference.any_io_executor.require.overload1 require]``(
      const Property & p,
      typename constraint< traits::require_member< const base_type &, const Property & >::is_valid >::type  = 0) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.require.overload1 more...]]``



  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.require.overload2 require]``(
      const execution::blocking_t::never_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.require.overload2 more...]]``

  template<
      typename Property>
  any_executor ``[link boost_asio.reference.any_io_executor.require.overload3 require]``(
      Property ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.require.overload3 more...]]``


[section:overload1 any_io_executor::require (1 of 3 overloads)]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor require(
      const Property & p,
      typename constraint< traits::require_member< const base_type &, const Property & >::is_valid >::type  = 0) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   any_io_executor ex = ...;
   auto ex2 = boost::asio::require(ex, execution::blocking.possibly); 





[endsect]



[section:overload2 any_io_executor::require (2 of 3 overloads)]



  template<>
  any_io_executor require(
      const execution::blocking_t::never_t & p,
      int ) const;



[endsect]



[section:overload3 any_io_executor::require (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor require(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::requre(ex, execution::blocking.possibly); 





[endsect]


[endsect]

[section:swap any_io_executor::swap]

[indexterm2 boost_asio.indexterm.any_io_executor.swap..swap..any_io_executor] 
Swap targets with another polymorphic wrapper. 


  void ``[link boost_asio.reference.any_io_executor.swap.overload1 swap]``(
      any_io_executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.swap.overload1 more...]]``

  void ``[link boost_asio.reference.any_io_executor.swap.overload2 swap]``(
      any_executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.swap.overload2 more...]]``


[section:overload1 any_io_executor::swap (1 of 2 overloads)]


Swap targets with another polymorphic wrapper. 


  void swap(
      any_io_executor & other);



[endsect]



[section:overload2 any_io_executor::swap (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Swap targets with another polymorphic wrapper. 


  void swap(
      any_executor & other);



[endsect]


[endsect]

[section:target any_io_executor::target]

[indexterm2 boost_asio.indexterm.any_io_executor.target..target..any_io_executor] 
Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * ``[link boost_asio.reference.any_io_executor.target.overload1 target]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.target.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * ``[link boost_asio.reference.any_io_executor.target.overload2 target]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.target.overload2 more...]]``


[section:overload1 any_io_executor::target (1 of 2 overloads)]


['Inherited from execution::any_executor.]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * target();



[endsect]



[section:overload2 any_io_executor::target (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * target() const;



[endsect]


[endsect]


[section:target_type any_io_executor::target_type]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.target_type..target_type..any_io_executor] 
Get the type of the target executor. 


  const type_info & target_type() const;



[endsect]



[section:_any_io_executor any_io_executor::~any_io_executor]

[indexterm2 boost_asio.indexterm.any_io_executor._any_io_executor..~any_io_executor..any_io_executor] 
Destructor. 


  ~any_io_executor();



[endsect]



[endsect]


[section:append append]

[indexterm1 boost_asio.indexterm.append..append]

Completion token type used to specify that the completion handler arguments should be passed additional values after the results of the operation. 


  template<
      typename CompletionToken,
      typename... Values>
  constexpr append_t< typename decay< CompletionToken >::type, typename decay< Values >::type...> append(
      CompletionToken && completion_token,
      Values &&... values);


[heading Requirements]

['Header: ][^boost/asio/append.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:append_t append_t]

[indexterm1 boost_asio.indexterm.append_t..append_t]


Completion token type used to specify that the completion handler arguments should be passed additional values after the results of the operation. 


  template<
      typename CompletionToken,
      typename... Values>
  class append_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.append_t.append_t [*append_t]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.append_t.token_ [*token_]]]
    []
  ]

  [
    [[link boost_asio.reference.append_t.values_ [*values_]]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/append.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:append_t append_t::append_t]

[indexterm2 boost_asio.indexterm.append_t.append_t..append_t..append_t] 
Constructor. 


  template<
      typename T,
      typename... V>
  constexpr append_t(
      T && completion_token,
      V &&... values);



[endsect]



[section:token_ append_t::token_]

[indexterm2 boost_asio.indexterm.append_t.token_..token_..append_t] 

  CompletionToken token_;



[endsect]



[section:values_ append_t::values_]

[indexterm2 boost_asio.indexterm.append_t.values_..values_..append_t] 

  std::tuple< Values...> values_;



[endsect]



[endsect]


[section:as_tuple as_tuple]

[indexterm1 boost_asio.indexterm.as_tuple..as_tuple]

Adapt a [link boost_asio.overview.model.completion_tokens completion token] to specify that the completion handler arguments should be combined into a single tuple argument. 


  template<
      typename CompletionToken>
  constexpr as_tuple_t< typename decay< CompletionToken >::type > as_tuple(
      CompletionToken && completion_token);


[heading Requirements]

['Header: ][^boost/asio/as_tuple.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:as_tuple_t as_tuple_t]

[indexterm1 boost_asio.indexterm.as_tuple_t..as_tuple_t]


A [link boost_asio.overview.model.completion_tokens completion token] adapter used to specify that the completion handler arguments should be combined into a single tuple argument. 


  template<
      typename CompletionToken>
  class as_tuple_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.as_tuple_t__default_constructor_tag [*default_constructor_tag]]]
    [Tag type used to prevent the "default" constructor from being used for conversions. ]
  
  ]

  [

    [[link boost_asio.reference.as_tuple_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the as_tuple_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.as_tuple_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use as_tuple_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.as_tuple_t.as_tuple_t [*as_tuple_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.as_tuple_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.as_tuple_t `as_tuple_t`] class is used to indicate that any arguments to the completion handler should be combined and passed as a single tuple argument. The arguments are first moved into a `std::tuple` and that tuple is then passed to the completion handler. 

[heading Requirements]

['Header: ][^boost/asio/as_tuple.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:as_default_on as_tuple_t::as_default_on]

[indexterm2 boost_asio.indexterm.as_tuple_t.as_default_on..as_default_on..as_tuple_t] 
Function helper to adapt an I/O object to use `as_tuple_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]


[section:as_tuple_t as_tuple_t::as_tuple_t]

[indexterm2 boost_asio.indexterm.as_tuple_t.as_tuple_t..as_tuple_t..as_tuple_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.as_tuple_t.as_tuple_t.overload1 as_tuple_t]``(
      default_constructor_tag  = default_constructor_tag(),
      CompletionToken token = CompletionToken());
  ``  [''''&raquo;''' [link boost_asio.reference.as_tuple_t.as_tuple_t.overload1 more...]]``


Constructor. 


  template<
      typename T>
  explicit constexpr ``[link boost_asio.reference.as_tuple_t.as_tuple_t.overload2 as_tuple_t]``(
      T && completion_token);
  ``  [''''&raquo;''' [link boost_asio.reference.as_tuple_t.as_tuple_t.overload2 more...]]``


[section:overload1 as_tuple_t::as_tuple_t (1 of 2 overloads)]


Default constructor. 


  constexpr as_tuple_t(
      default_constructor_tag  = default_constructor_tag(),
      CompletionToken token = CompletionToken());


This constructor is only valid if the underlying completion token is default constructible and move constructible. The underlying completion token is itself defaulted as an argument to allow it to capture a source location. 


[endsect]



[section:overload2 as_tuple_t::as_tuple_t (2 of 2 overloads)]


Constructor. 


  template<
      typename T>
  constexpr as_tuple_t(
      T && completion_token);



[endsect]


[endsect]


[section:token_ as_tuple_t::token_]

[indexterm2 boost_asio.indexterm.as_tuple_t.token_..token_..as_tuple_t] 

  CompletionToken token_;



[endsect]



[endsect]

[section:as_tuple_t__default_constructor_tag as_tuple_t::default_constructor_tag]

[indexterm1 boost_asio.indexterm.as_tuple_t__default_constructor_tag..as_tuple_t::default_constructor_tag]


Tag type used to prevent the "default" constructor from being used for conversions. 


  struct default_constructor_tag


[heading Requirements]

['Header: ][^boost/asio/as_tuple.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:as_tuple_t__executor_with_default as_tuple_t::executor_with_default]

[indexterm1 boost_asio.indexterm.as_tuple_t__executor_with_default..as_tuple_t::executor_with_default]


Adapts an executor to add the `as_tuple_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.as_tuple_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify as_tuple_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.as_tuple_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/as_tuple.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:default_completion_token_type as_tuple_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.as_tuple_t__executor_with_default.default_completion_token_type..default_completion_token_type..as_tuple_t::executor_with_default] 
Specify `as_tuple_t` as the default completion token type. 


  typedef as_tuple_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.as_tuple_t__default_constructor_tag [*default_constructor_tag]]]
    [Tag type used to prevent the "default" constructor from being used for conversions. ]
  
  ]

  [

    [[link boost_asio.reference.as_tuple_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the as_tuple_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.as_tuple_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use as_tuple_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.as_tuple_t.as_tuple_t [*as_tuple_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.as_tuple_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.as_tuple_t `as_tuple_t`] class is used to indicate that any arguments to the completion handler should be combined and passed as a single tuple argument. The arguments are first moved into a `std::tuple` and that tuple is then passed to the completion handler. 


[heading Requirements]

['Header: ][^boost/asio/as_tuple.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_with_default as_tuple_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.as_tuple_t__executor_with_default.executor_with_default..executor_with_default..as_tuple_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor1]``>
  executor_with_default(
      const InnerExecutor1 & ex,
      typename constraint< conditional< !is_same< InnerExecutor1, executor_with_default >::value, is_convertible< InnerExecutor1, InnerExecutor >, false_type >::type::value >::type  = 0);



[endsect]



[endsect]


[section:asio_handler_allocate asio_handler_allocate]

[indexterm1 boost_asio.indexterm.asio_handler_allocate..asio_handler_allocate]

(Deprecated: Use the [link boost_asio.reference.associated_allocator `associated_allocator`] trait.) Default allocation function for handlers. 


  asio_handler_allocate_is_deprecated asio_handler_allocate(
      std::size_t size,
      ... );


Asynchronous operations may need to allocate temporary objects. Since asynchronous operations have a handler function object, these temporary objects can be said to be associated with the handler.

Implement asio\_handler\_allocate and asio\_handler\_deallocate for your own handlers to provide custom allocation for these temporary objects.

The default implementation of these allocation hooks uses `operator new` and `operator delete`.


[heading Remarks]
      
All temporary objects associated with a handler will be deallocated before the upcall to the handler is performed. This allows the same memory to be reused for a subsequent asynchronous operation initiated by the handler.


[heading Example]
  


   class my_handler;

   void* asio_handler_allocate(std::size_t size, my_handler* context)
   {
     return ::operator new(size);
   }

   void asio_handler_deallocate(void* pointer, std::size_t size,
       my_handler* context)
   {
     ::operator delete(pointer);
   }






[heading Requirements]

['Header: ][^boost/asio/handler_alloc_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:asio_handler_deallocate asio_handler_deallocate]

[indexterm1 boost_asio.indexterm.asio_handler_deallocate..asio_handler_deallocate]

Default deallocation function for handlers. 


  asio_handler_deallocate_is_deprecated asio_handler_deallocate(
      void * pointer,
      std::size_t size,
      ... );


Implement asio\_handler\_allocate and asio\_handler\_deallocate for your own handlers to provide custom allocation for the associated temporary objects.

The default implementation of these allocation hooks uses `operator new` and `operator delete`.




[heading Requirements]

['Header: ][^boost/asio/handler_alloc_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:asio_handler_invoke asio_handler_invoke]

[indexterm1 boost_asio.indexterm.asio_handler_invoke..asio_handler_invoke]

(Deprecated: Use the [link boost_asio.reference.associated_executor `associated_executor`] trait.) Default invoke function for handlers. 


Default handler invocation hook used for non-const function objects. 

  template<
      typename Function>
  asio_handler_invoke_is_deprecated ``[link boost_asio.reference.asio_handler_invoke.overload1 asio_handler_invoke]``(
      Function & function,
      ... );
  ``  [''''&raquo;''' [link boost_asio.reference.asio_handler_invoke.overload1 more...]]``

Default handler invocation hook used for const function objects. 

  template<
      typename Function>
  asio_handler_invoke_is_deprecated ``[link boost_asio.reference.asio_handler_invoke.overload2 asio_handler_invoke]``(
      const Function & function,
      ... );
  ``  [''''&raquo;''' [link boost_asio.reference.asio_handler_invoke.overload2 more...]]``

Completion handlers for asynchronous operations are invoked by the [link boost_asio.reference.io_context `io_context`] associated with the corresponding object (e.g. a socket or deadline\_timer). Certain guarantees are made on when the handler may be invoked, in particular that a handler can only be invoked from a thread that is currently calling `run()` on the corresponding [link boost_asio.reference.io_context `io_context`] object. Handlers may subsequently be invoked through other objects (such as [link boost_asio.reference.io_context__strand `io_context::strand`] objects) that provide additional guarantees.

When asynchronous operations are composed from other asynchronous operations, all intermediate handlers should be invoked using the same method as the final handler. This is required to ensure that user-defined objects are not accessed in a way that may violate the guarantees. This hooking function ensures that the invoked method used for the final handler is accessible at each intermediate step.

Implement asio\_handler\_invoke for your own handlers to specify a custom invocation strategy.

This default implementation invokes the function object like so: 

   function(); 


If necessary, the default implementation makes a copy of the function object so that the non-const operator() can be used.


[heading Example]
  


   class my_handler;

   template <typename Function>
   void asio_handler_invoke(Function function, my_handler* context)
   {
     context->strand_.dispatch(function);
   }






[heading Requirements]

['Header: ][^boost/asio/handler_invoke_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 asio_handler_invoke (1 of 2 overloads)]


Default handler invocation hook used for non-const function objects. 


  template<
      typename Function>
  asio_handler_invoke_is_deprecated asio_handler_invoke(
      Function & function,
      ... );



[endsect]



[section:overload2 asio_handler_invoke (2 of 2 overloads)]


Default handler invocation hook used for const function objects. 


  template<
      typename Function>
  asio_handler_invoke_is_deprecated asio_handler_invoke(
      const Function & function,
      ... );



[endsect]


[endsect]


[section:asio_handler_is_continuation asio_handler_is_continuation]

[indexterm1 boost_asio.indexterm.asio_handler_is_continuation..asio_handler_is_continuation]

Default continuation function for handlers. 


  bool asio_handler_is_continuation(
      ... );


Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.

Implement asio\_handler\_is\_continuation for your own handlers to indicate when a handler represents a continuation.

The default implementation of the continuation hook returns `false`.


[heading Example]
  


   class my_handler;

   bool asio_handler_is_continuation(my_handler* context)
   {
     return true;
   }






[heading Requirements]

['Header: ][^boost/asio/handler_continuation_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:associated_allocator associated_allocator]

[indexterm1 boost_asio.indexterm.associated_allocator..associated_allocator]


Traits type used to obtain the allocator associated with an object. 


  template<
      typename T,
      typename Allocator = std::allocator<void>>
  struct associated_allocator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_allocator.type [*type]]]
    [If T has a nested type allocator_type, T::allocator_type. Otherwise Allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator.decltype [*decltype]] [static]]
    [If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns type(). 
     [hr]
     If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns a. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Allocator` shall be a type meeting the Allocator requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `a` is an object of type `Allocator`.


* Provide a nested typedef `type` that identifies a type meeting the Allocator requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,a)` and with return type `type` or a (possibly const) reference to `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:decltype associated_allocator::decltype]

[indexterm2 boost_asio.indexterm.associated_allocator.decltype..decltype..associated_allocator] 
If `T` has a nested type `allocator_type`, returns `t.get_allocator()`. Otherwise returns `type()`. 


  static static ``[link boost_asio.reference.associated_allocator.decltype.overload1 decltype]``(
      auto ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.associated_allocator.decltype.overload1 more...]]``


If `T` has a nested type `allocator_type`, returns `t.get_allocator()`. Otherwise returns `a`. 


  static static ``[link boost_asio.reference.associated_allocator.decltype.overload2 decltype]``(
      auto ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.associated_allocator.decltype.overload2 more...]]``


[section:overload1 associated_allocator::decltype (1 of 2 overloads)]


If `T` has a nested type `allocator_type`, returns `t.get_allocator()`. Otherwise returns `type()`. 


  static static decltype(
      auto ) const;



[endsect]



[section:overload2 associated_allocator::decltype (2 of 2 overloads)]


If `T` has a nested type `allocator_type`, returns `t.get_allocator()`. Otherwise returns `a`. 


  static static decltype(
      auto ) const;



[endsect]


[endsect]


[section:noexcept associated_allocator::noexcept]

[indexterm2 boost_asio.indexterm.associated_allocator.noexcept..noexcept..associated_allocator] 

  const Allocator &a noexcept;



[endsect]



[section:type associated_allocator::type]

[indexterm2 boost_asio.indexterm.associated_allocator.type..type..associated_allocator] 
If `T` has a nested type `allocator_type`, `T::allocator_type`. Otherwise `Allocator`. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_ associated_allocator< reference_wrapper< T >, Allocator >]

[indexterm1 boost_asio.indexterm.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_..associated_allocator< reference_wrapper< T >, Allocator >]


Specialisation of [link boost_asio.reference.associated_allocator `associated_allocator`] for `std::reference_wrapper`. 


  template<
      typename T,
      typename Allocator>
  struct associated_allocator< reference_wrapper< T >, Allocator >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.type [*type]]]
    [Forwards type to the associator specialisation for the unwrapped type T. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get [*get]] [static]]
    [Forwards the request to get the allocator to the associator specialisation for the unwrapped type T. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:get associated_allocator< reference_wrapper< T >, Allocator >::get]

[indexterm2 boost_asio.indexterm.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get..get..associated_allocator< reference_wrapper< T >, Allocator >] 
Forwards the request to get the allocator to the associator specialisation for the unwrapped type `T`. 


  static type ``[link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get.overload1 get]``(
      reference_wrapper< T > t);
  ``  [''''&raquo;''' [link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get.overload1 more...]]``

  static auto ``[link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get.overload2 get]``(
      reference_wrapper< T > t,
      const Allocator & a);
  ``  [''''&raquo;''' [link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get.overload2 more...]]``


[section:overload1 associated_allocator< reference_wrapper< T >, Allocator >::get (1 of 2 overloads)]


Forwards the request to get the allocator to the associator specialisation for the unwrapped type `T`. 


  static type get(
      reference_wrapper< T > t);



[endsect]



[section:overload2 associated_allocator< reference_wrapper< T >, Allocator >::get (2 of 2 overloads)]


Forwards the request to get the allocator to the associator specialisation for the unwrapped type `T`. 


  static auto get(
      reference_wrapper< T > t,
      const Allocator & a);



[endsect]


[endsect]


[section:type associated_allocator< reference_wrapper< T >, Allocator >::type]

[indexterm2 boost_asio.indexterm.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.type..type..associated_allocator< reference_wrapper< T >, Allocator >] 
Forwards `type` to the associator specialisation for the unwrapped type `T`. 


  typedef associated_allocator< T, Allocator >::type type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_allocator.type [*type]]]
    [If T has a nested type allocator_type, T::allocator_type. Otherwise Allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator.decltype [*decltype]] [static]]
    [If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns type(). 
     [hr]
     If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns a. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Allocator` shall be a type meeting the Allocator requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `a` is an object of type `Allocator`.


* Provide a nested typedef `type` that identifies a type meeting the Allocator requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,a)` and with return type `type` or a (possibly const) reference to `type`. 




[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_cancellation_slot associated_cancellation_slot]

[indexterm1 boost_asio.indexterm.associated_cancellation_slot..associated_cancellation_slot]


Traits type used to obtain the [link boost_asio.reference.cancellation_slot `cancellation_slot`] associated with an object. 


  template<
      typename T,
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]`` = cancellation_slot>
  struct associated_cancellation_slot


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_cancellation_slot.type [*type]]]
    [If T has a nested type cancellation_slot_type, T::cancellation_slot_type. Otherwise CancellationSlot. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_cancellation_slot.decltype [*decltype]] [static]]
    [If T has a nested type cancellation_slot_type, returns t.get_cancellation_slot(). Otherwise returns type(). 
     [hr]
     If T has a nested type cancellation_slot_type, returns t.get_cancellation_slot(). Otherwise returns s. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_cancellation_slot.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `CancellationSlot` shall be a type meeting the CancellationSlot requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `s` is an object of type `CancellationSlot`.


* Provide a nested typedef `type` that identifies a type meeting the CancellationSlot requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,s)` and with return type `type` or a (possibly const) reference to `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:decltype associated_cancellation_slot::decltype]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot.decltype..decltype..associated_cancellation_slot] 
If `T` has a nested type `cancellation_slot_type`, returns `t.get_cancellation_slot()`. Otherwise returns `type()`. 


  static static ``[link boost_asio.reference.associated_cancellation_slot.decltype.overload1 decltype]``(
      auto ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.associated_cancellation_slot.decltype.overload1 more...]]``


If `T` has a nested type `cancellation_slot_type`, returns `t.get_cancellation_slot()`. Otherwise returns `s`. 


  static static ``[link boost_asio.reference.associated_cancellation_slot.decltype.overload2 decltype]``(
      auto ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.associated_cancellation_slot.decltype.overload2 more...]]``


[section:overload1 associated_cancellation_slot::decltype (1 of 2 overloads)]


If `T` has a nested type `cancellation_slot_type`, returns `t.get_cancellation_slot()`. Otherwise returns `type()`. 


  static static decltype(
      auto ) const;



[endsect]



[section:overload2 associated_cancellation_slot::decltype (2 of 2 overloads)]


If `T` has a nested type `cancellation_slot_type`, returns `t.get_cancellation_slot()`. Otherwise returns `s`. 


  static static decltype(
      auto ) const;



[endsect]


[endsect]


[section:noexcept associated_cancellation_slot::noexcept]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot.noexcept..noexcept..associated_cancellation_slot] 

  const CancellationSlot &s noexcept;



[endsect]



[section:type associated_cancellation_slot::type]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot.type..type..associated_cancellation_slot] 
If `T` has a nested type `cancellation_slot_type`, `T::cancellation_slot_type`. Otherwise `CancellationSlot`. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_ associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >]

[indexterm1 boost_asio.indexterm.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_..associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >]


Specialisation of [link boost_asio.reference.associated_cancellation_slot `associated_cancellation_slot`] for `std::reference_wrapper`. 


  template<
      typename T,
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``>
  struct associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.type [*type]]]
    [Forwards type to the associator specialisation for the unwrapped type T. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.get [*get]] [static]]
    [Forwards the request to get the cancellation slot to the associator specialisation for the unwrapped type T. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:get associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >::get]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.get..get..associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >] 
Forwards the request to get the cancellation slot to the associator specialisation for the unwrapped type `T`. 


  static type ``[link boost_asio.reference.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.get.overload1 get]``(
      reference_wrapper< T > t);
  ``  [''''&raquo;''' [link boost_asio.reference.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.get.overload1 more...]]``

  static auto ``[link boost_asio.reference.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.get.overload2 get]``(
      reference_wrapper< T > t,
      const CancellationSlot & s);
  ``  [''''&raquo;''' [link boost_asio.reference.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.get.overload2 more...]]``


[section:overload1 associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >::get (1 of 2 overloads)]


Forwards the request to get the cancellation slot to the associator specialisation for the unwrapped type `T`. 


  static type get(
      reference_wrapper< T > t);



[endsect]



[section:overload2 associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >::get (2 of 2 overloads)]


Forwards the request to get the cancellation slot to the associator specialisation for the unwrapped type `T`. 


  static auto get(
      reference_wrapper< T > t,
      const CancellationSlot & s);



[endsect]


[endsect]


[section:type associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >::type]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot_lt__reference_wrapper_lt__T__gt__comma__CancellationSlot__gt_.type..type..associated_cancellation_slot< reference_wrapper< T >, CancellationSlot >] 
Forwards `type` to the associator specialisation for the unwrapped type `T`. 


  typedef associated_cancellation_slot< T, CancellationSlot >::type type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_cancellation_slot.type [*type]]]
    [If T has a nested type cancellation_slot_type, T::cancellation_slot_type. Otherwise CancellationSlot. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_cancellation_slot.decltype [*decltype]] [static]]
    [If T has a nested type cancellation_slot_type, returns t.get_cancellation_slot(). Otherwise returns type(). 
     [hr]
     If T has a nested type cancellation_slot_type, returns t.get_cancellation_slot(). Otherwise returns s. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_cancellation_slot.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `CancellationSlot` shall be a type meeting the CancellationSlot requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `s` is an object of type `CancellationSlot`.


* Provide a nested typedef `type` that identifies a type meeting the CancellationSlot requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,s)` and with return type `type` or a (possibly const) reference to `type`. 




[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_executor associated_executor]

[indexterm1 boost_asio.indexterm.associated_executor..associated_executor]


Traits type used to obtain the executor associated with an object. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]`` = system_executor>
  struct associated_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_executor.type [*type]]]
    [If T has a nested type executor_type, T::executor_type. Otherwise Executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor.decltype [*decltype]] [static]]
    [If T has a nested type executor_type, returns t.get_executor(). Otherwise returns type(). 
     [hr]
     If T has a nested type executor_type, returns t.get_executor(). Otherwise returns ex. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type` or a (possibly const) reference to `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:decltype associated_executor::decltype]

[indexterm2 boost_asio.indexterm.associated_executor.decltype..decltype..associated_executor] 
If `T` has a nested type `executor_type`, returns `t.get_executor()`. Otherwise returns `type()`. 


  static static ``[link boost_asio.reference.associated_executor.decltype.overload1 decltype]``(
      auto ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.associated_executor.decltype.overload1 more...]]``


If `T` has a nested type `executor_type`, returns `t.get_executor()`. Otherwise returns `ex`. 


  static static ``[link boost_asio.reference.associated_executor.decltype.overload2 decltype]``(
      auto ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.associated_executor.decltype.overload2 more...]]``


[section:overload1 associated_executor::decltype (1 of 2 overloads)]


If `T` has a nested type `executor_type`, returns `t.get_executor()`. Otherwise returns `type()`. 


  static static decltype(
      auto ) const;



[endsect]



[section:overload2 associated_executor::decltype (2 of 2 overloads)]


If `T` has a nested type `executor_type`, returns `t.get_executor()`. Otherwise returns `ex`. 


  static static decltype(
      auto ) const;



[endsect]


[endsect]


[section:noexcept associated_executor::noexcept]

[indexterm2 boost_asio.indexterm.associated_executor.noexcept..noexcept..associated_executor] 

  const Executor &ex noexcept;



[endsect]



[section:type associated_executor::type]

[indexterm2 boost_asio.indexterm.associated_executor.type..type..associated_executor] 
If `T` has a nested type `executor_type`, `T::executor_type`. Otherwise `Executor`. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_ associated_executor< reference_wrapper< T >, Executor >]

[indexterm1 boost_asio.indexterm.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_..associated_executor< reference_wrapper< T >, Executor >]


Specialisation of [link boost_asio.reference.associated_executor `associated_executor`] for `std::reference_wrapper`. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct associated_executor< reference_wrapper< T >, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.type [*type]]]
    [Forwards type to the associator specialisation for the unwrapped type T. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get [*get]] [static]]
    [Forwards the request to get the executor to the associator specialisation for the unwrapped type T. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:get associated_executor< reference_wrapper< T >, Executor >::get]

[indexterm2 boost_asio.indexterm.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get..get..associated_executor< reference_wrapper< T >, Executor >] 
Forwards the request to get the executor to the associator specialisation for the unwrapped type `T`. 


  static type ``[link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get.overload1 get]``(
      reference_wrapper< T > t);
  ``  [''''&raquo;''' [link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get.overload1 more...]]``

  static auto ``[link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get.overload2 get]``(
      reference_wrapper< T > t,
      const Executor & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get.overload2 more...]]``


[section:overload1 associated_executor< reference_wrapper< T >, Executor >::get (1 of 2 overloads)]


Forwards the request to get the executor to the associator specialisation for the unwrapped type `T`. 


  static type get(
      reference_wrapper< T > t);



[endsect]



[section:overload2 associated_executor< reference_wrapper< T >, Executor >::get (2 of 2 overloads)]


Forwards the request to get the executor to the associator specialisation for the unwrapped type `T`. 


  static auto get(
      reference_wrapper< T > t,
      const Executor & ex);



[endsect]


[endsect]


[section:type associated_executor< reference_wrapper< T >, Executor >::type]

[indexterm2 boost_asio.indexterm.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.type..type..associated_executor< reference_wrapper< T >, Executor >] 
Forwards `type` to the associator specialisation for the unwrapped type `T`. 


  typedef associated_executor< T, Executor >::type type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_executor.type [*type]]]
    [If T has a nested type executor_type, T::executor_type. Otherwise Executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor.decltype [*decltype]] [static]]
    [If T has a nested type executor_type, returns t.get_executor(). Otherwise returns type(). 
     [hr]
     If T has a nested type executor_type, returns t.get_executor(). Otherwise returns ex. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type` or a (possibly const) reference to `type`. 




[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_immediate_executor associated_immediate_executor]

[indexterm1 boost_asio.indexterm.associated_immediate_executor..associated_immediate_executor]


Traits type used to obtain the immediate executor associated with an object. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct associated_immediate_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_immediate_executor.type [*type]]]
    [If T has a nested type immediate_executor_type,. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_immediate_executor.decltype [*decltype]] [static]]
    [If T has a nested type immediate_executor_type, returns t.get_immediate_executor(). Otherwise returns boost::asio::require(ex, boost::asio::execution::blocking.never). ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_immediate_executor.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type` or a (possibly const) reference to `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_immediate_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:decltype associated_immediate_executor::decltype]

[indexterm2 boost_asio.indexterm.associated_immediate_executor.decltype..decltype..associated_immediate_executor] 
If `T` has a nested type `immediate_executor_type`, returns `t.get_immediate_executor()`. Otherwise returns `boost::asio::require(ex, boost::asio::execution::blocking.never)`. 


  static static decltype(
      auto ) const;



[endsect]



[section:noexcept associated_immediate_executor::noexcept]

[indexterm2 boost_asio.indexterm.associated_immediate_executor.noexcept..noexcept..associated_immediate_executor] 

  const Executor &ex noexcept;



[endsect]



[section:type associated_immediate_executor::type]

[indexterm2 boost_asio.indexterm.associated_immediate_executor.type..type..associated_immediate_executor] 
If `T` has a nested type `immediate_executor_type`,. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_immediate_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_immediate_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_ associated_immediate_executor< reference_wrapper< T >, Executor >]

[indexterm1 boost_asio.indexterm.associated_immediate_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_..associated_immediate_executor< reference_wrapper< T >, Executor >]


Specialisation of [link boost_asio.reference.associated_immediate_executor `associated_immediate_executor`] for `std::reference_wrapper`. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct associated_immediate_executor< reference_wrapper< T >, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_immediate_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.type [*type]]]
    [Forwards type to the associator specialisation for the unwrapped type T. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_immediate_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get [*get]] [static]]
    [Forwards the request to get the executor to the associator specialisation for the unwrapped type T. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/associated_immediate_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get associated_immediate_executor< reference_wrapper< T >, Executor >::get]

[indexterm2 boost_asio.indexterm.associated_immediate_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get..get..associated_immediate_executor< reference_wrapper< T >, Executor >] 
Forwards the request to get the executor to the associator specialisation for the unwrapped type `T`. 


  static auto get(
      reference_wrapper< T > t,
      const Executor & ex);



[endsect]



[section:type associated_immediate_executor< reference_wrapper< T >, Executor >::type]

[indexterm2 boost_asio.indexterm.associated_immediate_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.type..type..associated_immediate_executor< reference_wrapper< T >, Executor >] 
Forwards `type` to the associator specialisation for the unwrapped type `T`. 


  typedef associated_immediate_executor< T, Executor >::type type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_immediate_executor.type [*type]]]
    [If T has a nested type immediate_executor_type,. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_immediate_executor.decltype [*decltype]] [static]]
    [If T has a nested type immediate_executor_type, returns t.get_immediate_executor(). Otherwise returns boost::asio::require(ex, boost::asio::execution::blocking.never). ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_immediate_executor.noexcept [*noexcept]]]
    []
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type` or a (possibly const) reference to `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type` or a (possibly const) reference to `type`. 




[heading Requirements]

['Header: ][^boost/asio/associated_immediate_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associator associator]

[indexterm1 boost_asio.indexterm.associator..associator]


Used to generically specialise associators for a type. 


  template<
      template< typename, typename > class Associator,
      typename T,
      typename DefaultCandidate>
  struct associator


[heading Requirements]

['Header: ][^boost/asio/associator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:async_completion async_completion]

[indexterm1 boost_asio.indexterm.async_completion..async_completion]


Helper template to deduce the handler type from a CompletionToken, capture a local copy of the handler, and then create an [link boost_asio.reference.async_result `async_result`] for the handler. 


  template<
      typename CompletionToken,
      typename... Signatures>
  struct async_completion


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_completion.completion_handler_type [*completion_handler_type]]]
    [The real handler type to be used for the asynchronous operation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_completion.async_completion [*async_completion]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_completion.completion_handler [*completion_handler]]]
    [A copy of, or reference to, a real handler object. ]
  ]

  [
    [[link boost_asio.reference.async_completion.result [*result]]]
    [The result of the asynchronous operation's initiating function. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_completion async_completion::async_completion]

[indexterm2 boost_asio.indexterm.async_completion.async_completion..async_completion..async_completion] 
Constructor. 


  async_completion(
      CompletionToken & token);


The constructor creates the concrete completion handler and makes the link between the handler and the asynchronous result. 


[endsect]



[section:completion_handler async_completion::completion_handler]

[indexterm2 boost_asio.indexterm.async_completion.completion_handler..completion_handler..async_completion] 
A copy of, or reference to, a real handler object. 


  conditional< is_same< CompletionToken, completion_handler_type >::value, completion_handler_type &, completion_handler_type >::type completion_handler;



[endsect]



[section:completion_handler_type async_completion::completion_handler_type]

[indexterm2 boost_asio.indexterm.async_completion.completion_handler_type..completion_handler_type..async_completion] 
The real handler type to be used for the asynchronous operation. 


  typedef boost::asio::async_result< typename decay< CompletionToken >::type, Signatures... >::completion_handler_type completion_handler_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result.completion_handler_type [*completion_handler_type]]]
    [The concrete completion handler type for the specific signature. ]
  
  ]

  [

    [[link boost_asio.reference.async_result.return_type [*return_type]]]
    [The return type of the initiating function. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result.async_result [*async_result]] [constructor]]
    [Construct an async result from a given handler. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.get [*get]]]
    [Obtain the value to be returned from the initiating function. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.initiate [*initiate]] [static]]
    [Initiate the asynchronous operation that will produce the result, and obtain the value to be returned from the initiating function. ]
  ]
  
]

The [link boost_asio.reference.async_result `async_result`] traits class is used for determining:


* the concrete completion handler type to be called at the end of the asynchronous operation;


* the initiating function return type; and


* how the return value of the initiating function is obtained.

The trait allows the handler and return types to be determined at the point where the specific completion handler signature is known.

This template may be specialised for user-defined completion token types. The primary template assumes that the CompletionToken is the completion handler. 


[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:result async_completion::result]

[indexterm2 boost_asio.indexterm.async_completion.result..result..async_completion] 
The result of the asynchronous operation's initiating function. 


  async_result< typename decay< CompletionToken >::type, Signatures... > result;



[endsect]



[endsect]


[section:async_compose async_compose]

[indexterm1 boost_asio.indexterm.async_compose..async_compose]

Launch an asynchronous operation with a stateful implementation. 


  template<
      typename CompletionToken,
      typename Signature,
      typename Implementation,
      typename... IoObjectsOrExecutors>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_compose(
      Implementation && implementation,
      CompletionToken & token,
      IoObjectsOrExecutors &&... io_objects_or_executors);


The async\_compose function simplifies the implementation of composed asynchronous operations automatically wrapping a stateful function object with a conforming intermediate completion handler.


[heading Parameters]
    

[variablelist
  
[[implementation][A function object that contains the implementation of the composed asynchronous operation. The first argument to the function object is a non-const reference to the enclosing intermediate completion handler. The remaining arguments are any arguments that originate from the completion handlers of any asynchronous operations performed by the implementation.]]

[[token][The completion token.]]

[[io_objects_or_executors][Zero or more I/O objects or I/O executors for which outstanding work must be maintained.]]

]


[heading Example:]
  




   struct async_echo_implementation
   {
     tcp::socket& socket_;
     boost::asio::mutable_buffer buffer_;
     enum { starting, reading, writing } state_;

     template <typename Self>
     void operator()(Self& self,
         boost::system::error_code error = {},
         std::size_t n = 0)
     {
       switch (state_)
       {
       case starting:
         state_ = reading;
         socket_.async_read_some(
             buffer_, std::move(self));
         break;
       case reading:
         if (error)
         {
           self.complete(error, 0);
         }
         else
         {
           state_ = writing;
           boost::asio::async_write(socket_, buffer_,
               boost::asio::transfer_exactly(n),
               std::move(self));
         }
         break;
       case writing:
         self.complete(error, n);
         break;
       }
     }
   };

   template <typename CompletionToken>
   auto async_echo(tcp::socket& socket,
       boost::asio::mutable_buffer buffer,
       CompletionToken&& token) ->
     decltype(
       boost::asio::async_compose<CompletionToken,
         void(boost::system::error_code, std::size_t)>(
           std::declval<async_echo_implementation>(),
           token, socket))
   {
     return boost::asio::async_compose<CompletionToken,
       void(boost::system::error_code, std::size_t)>(
         async_echo_implementation{socket, buffer,
           async_echo_implementation::starting},
         token, socket);
   } 




[heading Requirements]

['Header: ][^boost/asio/compose.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:async_connect async_connect]

[indexterm1 boost_asio.indexterm.async_connect..async_connect]

The `async_connect` function is a composed asynchronous operation that establishes a socket connection by trying each endpoint in a sequence. 


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.RangeConnectToken RangeConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload1 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      RangeConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload1 more...]]``

(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload2 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload2 more...]]``

Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload3 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.RangeConnectToken RangeConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload4 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      RangeConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload4 more...]]``

(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload5 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload5 more...]]``

Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload6 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/connect.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_connect (1 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.RangeConnectToken RangeConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      RangeConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, the successfully connected endpoint.
     // Otherwise, a default-constructed endpoint.
     const typename Protocol::endpoint& endpoint
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, typename Protocol::endpoint) 





[heading Example]
  


   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const boost::system::error_code& ec,
       tcp::resolver::results_type results)
   {
     if (!ec)
     {
       boost::asio::async_connect(s, results, connect_handler);
     }
   }

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       const tcp::endpoint& endpoint)
   {
     // ...
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload2 async_connect (2 of 6 overloads)]


(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, Iterator) 





[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload3 async_connect (3 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, Iterator) 





[heading Example]
  


   std::vector<tcp::endpoint> endpoints = ...;
   tcp::socket s(my_context);
   boost::asio::async_connect(s,
       endpoints.begin(), endpoints.end(),
       connect_handler);

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       std::vector<tcp::endpoint>::iterator i)
   {
     // ...
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload4 async_connect (4 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.RangeConnectToken RangeConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      RangeConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, typename Protocol::endpoint) 





[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const boost::system::error_code& ec,
       tcp::resolver::results_type results)
   {
     if (!ec)
     {
       boost::asio::async_connect(s, results,
           my_connect_condition(),
           connect_handler);
     }
   }

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       const tcp::endpoint& endpoint)
   {
     if (ec)
     {
       // An error occurred.
     }
     else
     {
       std::cout << "Connected to: " << endpoint << std::endl;
     }
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload5 async_connect (5 of 6 overloads)]


(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, Iterator) 





[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload6 async_connect (6 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectToken IteratorConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      IteratorConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, Iterator) 





[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const boost::system::error_code& ec,
       tcp::resolver::iterator i)
   {
     if (!ec)
     {
       tcp::resolver::iterator end;
       boost::asio::async_connect(s, i, end,
           my_connect_condition(),
           connect_handler);
     }
   }

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       tcp::resolver::iterator i)
   {
     if (ec)
     {
       // An error occurred.
     }
     else
     {
       std::cout << "Connected to: " << i->endpoint() << std::endl;
     }
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]


[endsect]


[section:async_initiate async_initiate]

[indexterm1 boost_asio.indexterm.async_initiate..async_initiate]


  template<
      typename CompletionToken,
      completion_signature... Signatures,
      typename Initiation,
      typename... Args>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_initiate(
      Initiation && initiation,
      CompletionToken & ,
      Args &&... args);


[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:async_read async_read]

[indexterm1 boost_asio.indexterm.async_read..async_read]

The `async_read` function is a composed asynchronous operation that reads a certain amount of data from a stream before completion. 


Start an asynchronous operation to read a certain amount of data from a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload1 async_read]``(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload2 async_read]``(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload3 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload4 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload5 async_read]``(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload6 async_read]``(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload7 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload8 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload8 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_read (1 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_read(s, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload2 async_read (2 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_read(s,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`] documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload3 async_read (3 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload4 async_read (4 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload5 async_read (5 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, b,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload6 async_read (6 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload7 async_read (7 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload8 async_read (8 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]


[endsect]

[section:async_read_at async_read_at]

[indexterm1 boost_asio.indexterm.async_read_at..async_read_at]

The `async_read_at` function is a composed asynchronous operation that reads a certain amount of data at the specified offset. 


Start an asynchronous operation to read a certain amount of data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload1 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload2 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload3 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload4 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload4 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read_at.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_read_at (1 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_read_at(d, 42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read_at(
       d, 42, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]



[section:overload2 async_read_at (2 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async\_read\_some\_at function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_read_at(d, 42,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`] documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]



[section:overload3 async_read_at (3 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read_at(
       d, 42, b,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]



[section:overload4 async_read_at (4 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's async\_read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async\_read\_some\_at function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]


[endsect]

[section:async_read_until async_read_until]

[indexterm1 boost_asio.indexterm.async_read_until..async_read_until]

The `async_read_until` function is a composed asynchronous operation that reads data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. 


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload1 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload2 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload2 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload3 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload3 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload4 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload4 more...]]``

Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload5 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload6 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload6 more...]]``

Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload7 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload7 more...]]``

Start an asynchronous operation to read data into a streambuf until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload8 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload8 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload9 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload10 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload10 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload11 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload11 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload12 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload12 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read_until.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_read_until (1 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[delim][The delimiter character.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a newline is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload2 async_read_until (2 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[delim][The delimiter string.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload3 async_read_until (3 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[expr][The regular expression.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer
     // sequence's get area up to and including the
     // substring that matches the regular expression.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data,
       boost::regex("\r\n"), handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the match, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload4 async_read_until (4 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<typename DynamicBuffer_v1::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area that have been fully consumed by the match
     // function. O if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To asynchronously read data into a `std::string` until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::const_buffers_1> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_whitespace, handler);




To asynchronously read data into a `std::string` until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_char('a'), handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload5 async_read_until (5 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[delim][The delimiter character.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a streambuf until a newline is encountered: 

   boost::asio::streambuf b;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::istream is(&b);
       std::string line;
       std::getline(is, line);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, b, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `b` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload6 async_read_until (6 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[delim][The delimiter string.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a streambuf until a newline is encountered: 

   boost::asio::streambuf b;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::istream is(&b);
       std::string line;
       std::getline(is, line);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, b, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the buffer `b` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload7 async_read_until (7 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A substring of the streambuf's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the streambuf's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[expr][The regular expression.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area up to and including the substring
     // that matches the regular. expression.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a streambuf until a CR-LF sequence is encountered: 

   boost::asio::streambuf b;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::istream is(&b);
       std::string line;
       std::getline(is, line);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, b, boost::regex("\r\n"), handler); 


After the `async_read_until` operation completes successfully, the buffer `b` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload8 async_read_until (8 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);


This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area that have been fully consumed by the
     // match function. O if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To asynchronously read data into a streambuf until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::streambuf::const_buffers_type> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   boost::asio::streambuf b;
   boost::asio::async_read_until(s, b, match_whitespace, handler);




To asynchronously read data into a streambuf until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   boost::asio::streambuf b;
   boost::asio::async_read_until(s, b, match_char('a'), handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload9 async_read_until (9 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[delim][The delimiter character.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a newline is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload10 async_read_until (10 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[delim][The delimiter string.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload11 async_read_until (11 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[expr][The regular expression.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer
     // sequence's get area up to and including the
     // substring that matches the regular expression.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data,
       boost::regex("\r\n"), handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the match, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload12 async_read_until (12 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<typename DynamicBuffer_v2::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area that have been fully consumed by the match
     // function. O if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To asynchronously read data into a `std::string` until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::const_buffers_1> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_whitespace, handler);




To asynchronously read data into a `std::string` until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_char('a'), handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]


[endsect]

[section:async_result async_result]

[indexterm1 boost_asio.indexterm.async_result..async_result]


An interface for customising the behaviour of an initiating function. 


  template<
      typename CompletionToken,
      typename... Signatures>
  class async_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result.completion_handler_type [*completion_handler_type]]]
    [The concrete completion handler type for the specific signature. ]
  
  ]

  [

    [[link boost_asio.reference.async_result.return_type [*return_type]]]
    [The return type of the initiating function. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result.async_result [*async_result]] [constructor]]
    [Construct an async result from a given handler. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.get [*get]]]
    [Obtain the value to be returned from the initiating function. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.initiate [*initiate]] [static]]
    [Initiate the asynchronous operation that will produce the result, and obtain the value to be returned from the initiating function. ]
  ]
  
]

The [link boost_asio.reference.async_result `async_result`] traits class is used for determining:


* the concrete completion handler type to be called at the end of the asynchronous operation;


* the initiating function return type; and


* how the return value of the initiating function is obtained.

The trait allows the handler and return types to be determined at the point where the specific completion handler signature is known.

This template may be specialised for user-defined completion token types. The primary template assumes that the CompletionToken is the completion handler. 

[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_result async_result::async_result]

[indexterm2 boost_asio.indexterm.async_result.async_result..async_result..async_result] 
Construct an async result from a given handler. 


  async_result(
      completion_handler_type & h);


When using a specalised [link boost_asio.reference.async_result `async_result`], the constructor has an opportunity to initialise some state associated with the completion handler, which is then returned from the initiating function. 


[endsect]



[section:completion_handler_type async_result::completion_handler_type]

[indexterm2 boost_asio.indexterm.async_result.completion_handler_type..completion_handler_type..async_result] 
The concrete completion handler type for the specific signature. 


  typedef CompletionToken completion_handler_type;



[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get async_result::get]

[indexterm2 boost_asio.indexterm.async_result.get..get..async_result] 
Obtain the value to be returned from the initiating function. 


  return_type get();



[endsect]



[section:initiate async_result::initiate]

[indexterm2 boost_asio.indexterm.async_result.initiate..initiate..async_result] 
Initiate the asynchronous operation that will produce the result, and obtain the value to be returned from the initiating function. 


  template<
      typename Initiation,
      typename RawCompletionToken,
      typename... Args>
  static return_type initiate(
      Initiation && initiation,
      RawCompletionToken && token,
      Args &&... args);



[endsect]



[section:return_type async_result::return_type]

[indexterm2 boost_asio.indexterm.async_result.return_type..return_type..async_result] 
The return type of the initiating function. 


  typedef void return_type;



[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_ async_result< basic_yield_context< Executor >, Signature >]

[indexterm1 boost_asio.indexterm.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_..async_result< basic_yield_context< Executor >, Signature >]



  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Signature>
  class async_result< basic_yield_context< Executor >, Signature >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_.handler_type [*handler_type]]]
    []
  
  ]

  [

    [[link boost_asio.reference.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_.return_type [*return_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_.initiate [*initiate]] [static]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/impl/spawn.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:handler_type async_result< basic_yield_context< Executor >, Signature >::handler_type]

[indexterm2 boost_asio.indexterm.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_.handler_type..handler_type..async_result< basic_yield_context< Executor >, Signature >] 

  typedef detail::spawn_handler< Executor, Signature > handler_type;



[heading Requirements]

['Header: ][^boost/asio/impl/spawn.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:initiate async_result< basic_yield_context< Executor >, Signature >::initiate]

[indexterm2 boost_asio.indexterm.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_.initiate..initiate..async_result< basic_yield_context< Executor >, Signature >] 

  template<
      typename Initiation>
  static return_type initiate(
      Initiation init,
      const basic_yield_context< Executor > & yield);



[endsect]



[section:return_type async_result< basic_yield_context< Executor >, Signature >::return_type]

[indexterm2 boost_asio.indexterm.async_result_lt__basic_yield_context_lt__Executor__gt__comma__Signature__gt_.return_type..return_type..async_result< basic_yield_context< Executor >, Signature >] 

  typedef handler_type::return_type return_type;



[heading Requirements]

['Header: ][^boost/asio/impl/spawn.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_ async_result< std::packaged_task< Result(Args...)>, Signature >]

[indexterm1 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >]


Partial specialisation of `async_result` for `std::packaged_task`. 


  template<
      typename Result,
      typename... Args,
      typename Signature>
  class async_result< std::packaged_task< Result(Args...)>, Signature >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.completion_handler_type [*completion_handler_type]]]
    [The packaged task is the concrete completion handler type. ]
  
  ]

  [

    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.return_type [*return_type]]]
    [The return type of the initiating function is the future obtained from the packaged task. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.async_result [*async_result]]]
    [The constructor extracts the future from the packaged task. ]
  ]
  
  [
    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.get [*get]]]
    [Returns the packaged task's future. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/packaged_task.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_result async_result< std::packaged_task< Result(Args...)>, Signature >::async_result]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.async_result..async_result..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
The constructor extracts the future from the packaged task. 


  async_result(
      completion_handler_type & h);



[endsect]



[section:completion_handler_type async_result< std::packaged_task< Result(Args...)>, Signature >::completion_handler_type]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.completion_handler_type..completion_handler_type..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
The packaged task is the concrete completion handler type. 


  typedef std::packaged_task< Result(Args...)> completion_handler_type;



[heading Requirements]

['Header: ][^boost/asio/packaged_task.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get async_result< std::packaged_task< Result(Args...)>, Signature >::get]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.get..get..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
Returns the packaged task's future. 


  return_type get();



[endsect]



[section:return_type async_result< std::packaged_task< Result(Args...)>, Signature >::return_type]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.return_type..return_type..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
The return type of the initiating function is the future obtained from the packaged task. 


  typedef std::future< Result > return_type;



[heading Requirements]

['Header: ][^boost/asio/packaged_task.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:async_write async_write]

[indexterm1 boost_asio.indexterm.async_write..async_write]

The `async_write` function is a composed asynchronous operation that writes a certain amount of data to a stream before completion. 


Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload1 async_write]``(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload1 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload2 async_write]``(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteToken && token,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload2 more...]]``

Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload3 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload3 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload4 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      WriteToken && token,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload4 more...]]``

Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload5 async_write]``(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload5 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload6 async_write]``(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload6 more...]]``

Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload7 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload7 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload8 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      WriteToken && token,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload8 more...]]``

[heading Requirements]

['Header: ][^boost/asio/write.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_write (1 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_write(s, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload2 async_write (2 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteToken && token,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_write(s,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`] documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload3 async_write (3 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload4 async_write (4 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      WriteToken && token,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload5 async_write (5 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload6 async_write (6 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteToken && token);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload7 async_write (7 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload8 async_write (8 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      WriteToken && token,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]


[endsect]

[section:async_write_at async_write_at]

[indexterm1 boost_asio.indexterm.async_write_at..async_write_at]

The `async_write_at` function is a composed asynchronous operation that writes a certain amount of data at the specified offset before completion. 


Start an asynchronous operation to write all of the supplied data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload1 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload1 more...]]``

Start an asynchronous operation to write a certain amount of data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload2 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload2 more...]]``

Start an asynchronous operation to write all of the supplied data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload3 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload3 more...]]``

Start an asynchronous operation to write a certain amount of data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload4 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload4 more...]]``

[heading Requirements]

['Header: ][^boost/asio/write_at.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_write_at (1 of 4 overloads)]


Start an asynchronous operation to write all of the supplied data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_write_at(d, 42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]



[section:overload2 async_write_at (2 of 4 overloads)]


Start an asynchronous operation to write a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async\_write\_some\_at function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::async_write_at(d, 42,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`] documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]



[section:overload3 async_write_at (3 of 4 overloads)]


Start an asynchronous operation to write all of the supplied data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]



[section:overload4 async_write_at (4 of 4 overloads)]


Start an asynchronous operation to write a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async\_write\_some\_at function.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]


[endsect]

[section:awaitable awaitable]

[indexterm1 boost_asio.indexterm.awaitable..awaitable]


The return type of a coroutine or asynchronous operation. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class awaitable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.awaitable.executor_type [*executor_type]]]
    [The executor type that will be used for the coroutine. ]
  
  ]

  [

    [[link boost_asio.reference.awaitable.value_type [*value_type]]]
    [The type of the awaited value. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.awaitable.awaitable [*awaitable]] [constructor]]
    [Default constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.awaitable.operator_eq_ [*operator=]]]
    [Move assignment. ]
  ]
  
  [
    [[link boost_asio.reference.awaitable.valid [*valid]]]
    [Checks if the awaitable refers to a future result. ]
  ]
  
  [
    [[link boost_asio.reference.awaitable._awaitable [*~awaitable]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:awaitable awaitable::awaitable]

[indexterm2 boost_asio.indexterm.awaitable.awaitable..awaitable..awaitable] 
Default constructor. 


  constexpr ``[link boost_asio.reference.awaitable.awaitable.overload1 awaitable]``();
  ``  [''''&raquo;''' [link boost_asio.reference.awaitable.awaitable.overload1 more...]]``


Move constructor. 


  ``[link boost_asio.reference.awaitable.awaitable.overload2 awaitable]``(
      awaitable && other);
  ``  [''''&raquo;''' [link boost_asio.reference.awaitable.awaitable.overload2 more...]]``


[section:overload1 awaitable::awaitable (1 of 2 overloads)]


Default constructor. 


  constexpr awaitable();



[endsect]



[section:overload2 awaitable::awaitable (2 of 2 overloads)]


Move constructor. 


  awaitable(
      awaitable && other);



[endsect]


[endsect]


[section:executor_type awaitable::executor_type]

[indexterm2 boost_asio.indexterm.awaitable.executor_type..executor_type..awaitable] 
The executor type that will be used for the coroutine. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ awaitable::operator=]

[indexterm2 boost_asio.indexterm.awaitable.operator_eq_..operator=..awaitable] 
Move assignment. 


  awaitable & operator=(
      awaitable && other);



[endsect]



[section:valid awaitable::valid]

[indexterm2 boost_asio.indexterm.awaitable.valid..valid..awaitable] 
Checks if the awaitable refers to a future result. 


  bool valid() const;



[endsect]



[section:value_type awaitable::value_type]

[indexterm2 boost_asio.indexterm.awaitable.value_type..value_type..awaitable] 
The type of the awaited value. 


  typedef T value_type;



[heading Requirements]

['Header: ][^boost/asio/awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_awaitable awaitable::~awaitable]

[indexterm2 boost_asio.indexterm.awaitable._awaitable..~awaitable..awaitable] 
Destructor. 


  ~awaitable();



[endsect]



[endsect]

[section:bad_executor bad_executor]

[indexterm1 boost_asio.indexterm.bad_executor..bad_executor]


Exception thrown when trying to access an empty polymorphic executor. 


  class bad_executor :
    public std::exception


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.bad_executor.bad_executor [*bad_executor]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.bad_executor.what [*what]]]
    [Obtain message associated with exception. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:bad_executor bad_executor::bad_executor]

[indexterm2 boost_asio.indexterm.bad_executor.bad_executor..bad_executor..bad_executor] 
Constructor. 


  bad_executor();



[endsect]



[section:what bad_executor::what]

[indexterm2 boost_asio.indexterm.bad_executor.what..what..bad_executor] 
Obtain message associated with exception. 


  virtual const char * what() const;



[endsect]



[endsect]

[section:basic_datagram_socket basic_datagram_socket]

[indexterm1 boost_asio.indexterm.basic_datagram_socket..basic_datagram_socket]


Provides datagram-oriented socket functionality. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_datagram_socket :
    public basic_socket< Protocol, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]] [constructor]]
    [Construct a basic_datagram_socket without opening it. 
     [hr]
     Construct and open a basic_datagram_socket. 
     [hr]
     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_datagram_socket on an existing native socket. 
     [hr]
     Move-construct a basic_datagram_socket from another. 
     [hr]
     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 
     [hr]
     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, `connect`, and `shutdown` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 

[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_datagram_socket::assign]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.assign..assign..basic_datagram_socket] 
Assign an existing native socket to the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.assign.overload2 more...]]``


[section:overload1 basic_datagram_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_datagram_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_datagram_socket::async_connect]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_connect..async_connect..basic_datagram_socket] 
Start an asynchronous connect. 


  template<
      typename ``[link boost_asio.reference.ConnectToken ConnectToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      const endpoint_type & peer_endpoint,
      ConnectToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously connect a socket to the specified remote endpoint. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code) 





[heading Example]
  


   void connect_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:async_receive basic_datagram_socket::async_receive]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_receive..async_receive..basic_datagram_socket] 
Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the datagram socket. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the receive completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected datagram socket.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   socket.async_receive(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the datagram socket. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the receive completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected datagram socket.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_receive_from basic_datagram_socket::async_receive_from]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_receive_from..async_receive_from..basic_datagram_socket] 
Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive_from.overload1 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive_from.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive_from.overload2 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive_from.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_receive_from (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive a datagram. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the receive completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   socket.async_receive_from(
       boost::asio::buffer(data, size), sender_endpoint, handler); 


See the [link boost_asio.reference.buffer `buffer`] documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_receive_from (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadToken ReadToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive a datagram. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the completion handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the receive completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send basic_datagram_socket::async_send]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_send..async_send..basic_datagram_socket] 
Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send.overload1 async_send]``(
      const ConstBufferSequence & buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send.overload2 async_send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_send (1 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the datagram socket. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the send completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected datagram socket.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   socket.async_send(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_send (2 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the datagram socket. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the send completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected datagram socket.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send_to basic_datagram_socket::async_send_to]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_send_to..async_send_to..basic_datagram_socket] 
Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send_to.overload1 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send_to.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send_to.overload2 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send_to.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_send_to (1 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send a datagram to the specified remote endpoint. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the send completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`] function as follows: 

   boost::asio::ip::udp::endpoint destination(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_send_to(
       boost::asio::buffer(data, size), destination, handler);


See the [link boost_asio.reference.buffer `buffer`] documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_send_to (2 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteToken WriteToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send a datagram to the specified remote endpoint. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the send completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code, std::size_t) 





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]


[section:async_wait basic_datagram_socket::async_wait]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_wait..async_wait..basic_datagram_socket] 
Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitToken WaitToken]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state. It is an initiating function for an [link boost_asio.overview.model.async_ops asynchronous operation], and always returns immediately.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[token][The [link boost_asio.overview.model.completion_tokens completion token] that will be used to produce a completion handler, which will be called when the wait completes. Potential completion tokens include [link boost_asio.reference.use_future `use_future`], [link boost_asio.reference.use_awaitable `use_awaitable`], [link boost_asio.reference.yield_context `yield_context`], or a function object with the correct completion signature. The function signature of the completion handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Completion Signature]
  


   void(boost::system::error_code) 





[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:at_mark basic_datagram_socket::at_mark]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.at_mark..at_mark..basic_datagram_socket] 
Determine whether the socket is at the out-of-band data mark. 


  bool ``[link boost_asio.reference.basic_datagram_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.at_mark.overload1 more...]]``

  bool ``[link boost_asio.reference.basic_datagram_socket.at_mark.overload2 at_mark]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.at_mark.overload2 more...]]``


[section:overload1 basic_datagram_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      boost::system::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_datagram_socket::available]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.available..available..basic_datagram_socket] 
Determine the number of bytes available for reading. 


  std::size_t ``[link boost_asio.reference.basic_datagram_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.available.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_datagram_socket.available.overload2 available]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.available.overload2 more...]]``


[section:overload1 basic_datagram_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      boost::system::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_datagram_socket basic_datagram_socket::basic_datagram_socket]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.basic_datagram_socket..basic_datagram_socket..basic_datagram_socket] 
Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  explicit ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload1 basic_datagram_socket]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload2 basic_datagram_socket]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`]. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload3 basic_datagram_socket]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload4 basic_datagram_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload4 more...]]``


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload5 basic_datagram_socket]``(
      const executor_type & ex,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload6 basic_datagram_socket]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload6 more...]]``


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload7 basic_datagram_socket]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload8 basic_datagram_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload9 basic_datagram_socket]``(
      basic_datagram_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload10 basic_datagram_socket]``(
      basic_datagram_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload10 more...]]``


[section:overload1 basic_datagram_socket::basic_datagram_socket (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  basic_datagram_socket(
      const executor_type & ex);


This constructor creates a datagram socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::basic_datagram_socket (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a datagram socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::basic_datagram_socket (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`]. 


  basic_datagram_socket(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates and opens a datagram socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_datagram_socket::basic_datagram_socket (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`]. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a datagram socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_datagram_socket::basic_datagram_socket (5 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  basic_datagram_socket(
      const executor_type & ex,
      const endpoint_type & endpoint);


This constructor creates a datagram socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the datagram socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_datagram_socket::basic_datagram_socket (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a datagram socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the datagram socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_datagram_socket::basic_datagram_socket (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  basic_datagram_socket(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a datagram socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_datagram_socket::basic_datagram_socket (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a datagram socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_datagram_socket::basic_datagram_socket (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket(
      basic_datagram_socket && other);


This constructor moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_datagram_socket::basic_datagram_socket (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_datagram_socket(
      basic_datagram_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:bind basic_datagram_socket::bind]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.bind..bind..basic_datagram_socket] 
Bind the socket to the given local endpoint. 


  void ``[link boost_asio.reference.basic_datagram_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.bind.overload2 more...]]``


[section:overload1 basic_datagram_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_datagram_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   boost::system::error_code ec;
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_datagram_socket::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.broadcast..broadcast..basic_datagram_socket] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_datagram_socket::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.bytes_readable..bytes_readable..basic_datagram_socket] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_datagram_socket::cancel]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.cancel..cancel..basic_datagram_socket] 
Cancel all asynchronous operations associated with the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.cancel.overload2 more...]]``


[section:overload1 basic_datagram_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_datagram_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_datagram_socket::close]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.close..close..basic_datagram_socket] 
Close the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.close.overload2 more...]]``


[section:overload1 basic_datagram_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_datagram_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      boost::system::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_datagram_socket::connect]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.connect..connect..basic_datagram_socket] 
Connect the socket to the specified endpoint. 


  void ``[link boost_asio.reference.basic_datagram_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.connect.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.connect.overload2 more...]]``


[section:overload1 basic_datagram_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_datagram_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   boost::system::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_datagram_socket::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.debug..debug..basic_datagram_socket] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_datagram_socket::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.do_not_route..do_not_route..basic_datagram_socket] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_datagram_socket::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.enable_connection_aborted..enable_connection_aborted..basic_datagram_socket] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_datagram_socket::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.endpoint_type..endpoint_type..basic_datagram_socket] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_datagram_socket::executor_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.executor_type..executor_type..basic_datagram_socket] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_datagram_socket::get_executor]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.get_executor..get_executor..basic_datagram_socket] 
Get the executor associated with the object. 


  const executor_type & get_executor();



[endsect]


[section:get_option basic_datagram_socket::get_option]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.get_option..get_option..basic_datagram_socket] 
Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_datagram_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_datagram_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.get_option.overload2 more...]]``


[section:overload1 basic_datagram_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_datagram_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   boost::system::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_datagram_socket::io_control]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.io_control..io_control..basic_datagram_socket] 
Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_datagram_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_datagram_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.io_control.overload2 more...]]``


[section:overload1 basic_datagram_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_datagram_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_datagram_socket::is_open]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.is_open..is_open..basic_datagram_socket] 
Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_datagram_socket::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.keep_alive..keep_alive..basic_datagram_socket] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_datagram_socket::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.linger..linger..basic_datagram_socket] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:local_endpoint basic_datagram_socket::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.local_endpoint..local_endpoint..basic_datagram_socket] 
Get the local endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_datagram_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_datagram_socket.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_datagram_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_datagram_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:lowest_layer basic_datagram_socket::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.lowest_layer..lowest_layer..basic_datagram_socket] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_datagram_socket.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_datagram_socket.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.lowest_layer.overload2 more...]]``


[section:overload1 basic_datagram_socket::lowest_layer (1 of 2 overloads)]


['Inherited from basic_socket.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_datagram_socket::lowest_layer (2 of 2 overloads)]


['Inherited from basic_socket.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_datagram_socket::lowest_layer_type]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.lowest_layer_type..lowest_layer_type..basic_datagram_socket] 
A [link boost_asio.reference.basic_socket `basic_socket`] is always the lowest layer. 


  typedef basic_socket< Protocol, Executor > lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections basic_datagram_socket::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.max_connections..max_connections..basic_datagram_socket] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_datagram_socket::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.max_listen_connections..max_listen_connections..basic_datagram_socket] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_datagram_socket::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_do_not_route..message_do_not_route..basic_datagram_socket] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_datagram_socket::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_end_of_record..message_end_of_record..basic_datagram_socket] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_datagram_socket::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_flags..message_flags..basic_datagram_socket] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_datagram_socket::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_out_of_band..message_out_of_band..basic_datagram_socket] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_datagram_socket::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_peek..message_peek..basic_datagram_socket] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_datagram_socket::native_handle]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.native_handle..native_handle..basic_datagram_socket] 
Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_datagram_socket::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.native_handle_type..native_handle_type..basic_datagram_socket] 
The native representation of a socket. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_datagram_socket::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.native_non_blocking..native_non_blocking..basic_datagram_socket] 
Gets the non-blocking mode of the native socket implementation. 


  bool ``[link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_datagram_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_datagram_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_datagram_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the un